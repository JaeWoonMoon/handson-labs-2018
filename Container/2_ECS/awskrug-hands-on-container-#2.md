<!----- Conversion time: 42.895 seconds.


Using this Markdown file:

1. Cut and paste this output into your source file.
2. See the notes and action items below regarding this conversion run.
3. Check the rendered output (headings, lists, code blocks, tables) for proper
   formatting and use a linkchecker before you publish this page.

Conversion notes:

* GD2md-html version 1.0β13
* Fri Oct 26 2018 00:55:40 GMT-0700 (PDT)
* Source doc: https://docs.google.com/open?id=1NQMN0Z5uRkOJlN2owtJbE6rfIqnLelK6hFfXSMDuoCQ
* This document has images: check for >>>>>  gd2md-html alert:  inline image link in generated source and store images to your server.
----->


<p style="color: red; font-weight: bold">>>>>>  gd2md-html alert:  ERRORs: 0; WARNINGs: 0; ALERTS: 125.</p>
<ul style="color: red; font-weight: bold"><li>See top comment block for details on ERRORs and WARNINGs. <li>In the converted Markdown or HTML, search for inline alerts that start with >>>>>  gd2md-html alert:  for specific instances that need correction.</ul>

<p style="color: red; font-weight: bold">Links to alert messages:</p><a href="#gdcalert1">alert1</a>
<a href="#gdcalert2">alert2</a>
<a href="#gdcalert3">alert3</a>
<a href="#gdcalert4">alert4</a>
<a href="#gdcalert5">alert5</a>
<a href="#gdcalert6">alert6</a>
<a href="#gdcalert7">alert7</a>
<a href="#gdcalert8">alert8</a>
<a href="#gdcalert9">alert9</a>
<a href="#gdcalert10">alert10</a>
<a href="#gdcalert11">alert11</a>
<a href="#gdcalert12">alert12</a>
<a href="#gdcalert13">alert13</a>
<a href="#gdcalert14">alert14</a>
<a href="#gdcalert15">alert15</a>
<a href="#gdcalert16">alert16</a>
<a href="#gdcalert17">alert17</a>
<a href="#gdcalert18">alert18</a>
<a href="#gdcalert19">alert19</a>
<a href="#gdcalert20">alert20</a>
<a href="#gdcalert21">alert21</a>
<a href="#gdcalert22">alert22</a>
<a href="#gdcalert23">alert23</a>
<a href="#gdcalert24">alert24</a>
<a href="#gdcalert25">alert25</a>
<a href="#gdcalert26">alert26</a>
<a href="#gdcalert27">alert27</a>
<a href="#gdcalert28">alert28</a>
<a href="#gdcalert29">alert29</a>
<a href="#gdcalert30">alert30</a>
<a href="#gdcalert31">alert31</a>
<a href="#gdcalert32">alert32</a>
<a href="#gdcalert33">alert33</a>
<a href="#gdcalert34">alert34</a>
<a href="#gdcalert35">alert35</a>
<a href="#gdcalert36">alert36</a>
<a href="#gdcalert37">alert37</a>
<a href="#gdcalert38">alert38</a>
<a href="#gdcalert39">alert39</a>
<a href="#gdcalert40">alert40</a>
<a href="#gdcalert41">alert41</a>
<a href="#gdcalert42">alert42</a>
<a href="#gdcalert43">alert43</a>
<a href="#gdcalert44">alert44</a>
<a href="#gdcalert45">alert45</a>
<a href="#gdcalert46">alert46</a>
<a href="#gdcalert47">alert47</a>
<a href="#gdcalert48">alert48</a>
<a href="#gdcalert49">alert49</a>
<a href="#gdcalert50">alert50</a>
<a href="#gdcalert51">alert51</a>
<a href="#gdcalert52">alert52</a>
<a href="#gdcalert53">alert53</a>
<a href="#gdcalert54">alert54</a>
<a href="#gdcalert55">alert55</a>
<a href="#gdcalert56">alert56</a>
<a href="#gdcalert57">alert57</a>
<a href="#gdcalert58">alert58</a>
<a href="#gdcalert59">alert59</a>
<a href="#gdcalert60">alert60</a>
<a href="#gdcalert61">alert61</a>
<a href="#gdcalert62">alert62</a>
<a href="#gdcalert63">alert63</a>
<a href="#gdcalert64">alert64</a>
<a href="#gdcalert65">alert65</a>
<a href="#gdcalert66">alert66</a>
<a href="#gdcalert67">alert67</a>
<a href="#gdcalert68">alert68</a>
<a href="#gdcalert69">alert69</a>
<a href="#gdcalert70">alert70</a>
<a href="#gdcalert71">alert71</a>
<a href="#gdcalert72">alert72</a>
<a href="#gdcalert73">alert73</a>
<a href="#gdcalert74">alert74</a>
<a href="#gdcalert75">alert75</a>
<a href="#gdcalert76">alert76</a>
<a href="#gdcalert77">alert77</a>
<a href="#gdcalert78">alert78</a>
<a href="#gdcalert79">alert79</a>
<a href="#gdcalert80">alert80</a>
<a href="#gdcalert81">alert81</a>
<a href="#gdcalert82">alert82</a>
<a href="#gdcalert83">alert83</a>
<a href="#gdcalert84">alert84</a>
<a href="#gdcalert85">alert85</a>
<a href="#gdcalert86">alert86</a>
<a href="#gdcalert87">alert87</a>
<a href="#gdcalert88">alert88</a>
<a href="#gdcalert89">alert89</a>
<a href="#gdcalert90">alert90</a>
<a href="#gdcalert91">alert91</a>
<a href="#gdcalert92">alert92</a>
<a href="#gdcalert93">alert93</a>
<a href="#gdcalert94">alert94</a>
<a href="#gdcalert95">alert95</a>
<a href="#gdcalert96">alert96</a>
<a href="#gdcalert97">alert97</a>
<a href="#gdcalert98">alert98</a>
<a href="#gdcalert99">alert99</a>
<a href="#gdcalert100">alert100</a>
<a href="#gdcalert101">alert101</a>
<a href="#gdcalert102">alert102</a>
<a href="#gdcalert103">alert103</a>
<a href="#gdcalert104">alert104</a>
<a href="#gdcalert105">alert105</a>
<a href="#gdcalert106">alert106</a>
<a href="#gdcalert107">alert107</a>
<a href="#gdcalert108">alert108</a>
<a href="#gdcalert109">alert109</a>
<a href="#gdcalert110">alert110</a>
<a href="#gdcalert111">alert111</a>
<a href="#gdcalert112">alert112</a>
<a href="#gdcalert113">alert113</a>
<a href="#gdcalert114">alert114</a>
<a href="#gdcalert115">alert115</a>
<a href="#gdcalert116">alert116</a>
<a href="#gdcalert117">alert117</a>
<a href="#gdcalert118">alert118</a>
<a href="#gdcalert119">alert119</a>
<a href="#gdcalert120">alert120</a>
<a href="#gdcalert121">alert121</a>
<a href="#gdcalert122">alert122</a>
<a href="#gdcalert123">alert123</a>
<a href="#gdcalert124">alert124</a>
<a href="#gdcalert125">alert125</a>

<p style="color: red; font-weight: bold">>>>>> PLEASE check and correct alert issues and delete this message and the inline alerts.<hr></p>



# Container Hands-On #2 - ECS


```
이 장의 내용
이번 컨테이너 헨즈온 두번째 세션에서는 Amazon Web Service(이하 AWS)에서 제공하는 컨테이너 오케스트레이션 도구인 Elastic Container Service(이하 ECS)에 대해서 다뤄보려고 합니다. 주어진 시나리오에 따라서 ECS에 대해서 알아보고 실습을 진행합니다.

Hands-on 과정의 대상독자는 다음과 같습니다. 첫번째 웹서비스를 개발하고 배포해본 경험이 있는 사람입니다. 두번째 Dockerfile을 통해서 도커 이미지를 만들어보고 그를 컨테이너로써 실행해본 경험이 있는 사람입니다. 두가지 경험이 있어야지 이번 과정을 큰 무리없이 진행할 수 있을 것입니다. 만약 그렇지 않더라도 단계별로 똑같이 차근차근 따라하다 보면 실습에 참여하실 수 있고 이번 과정의 의도를 느끼실 수 있을 것입니다.

Hands-on 과정을 진행하려면 IAM 권한을 가진 AWS 계정, github 계정이 필요합니다. 실습은 환경의 영향을 최소화하기 위해서 AWS의 cloud9이라는 웹기반 IDE를 사용할 예정입니다. 그리고 2018.10월 현재, cloud9이 있는 싱가포르 리전에서 실습을 진행합니다.

이번 실습은 프리티어의 범위를 벗어나는 실습입니다. 차근차근 따라하시고 나서 꼭 서비스들을 지워주시기 바랍니다. 
```


이번 실습에서 우리는 가상의 회사인 Petclinic 개발팀의 서버 개발자가 됩니다. 서버 개발자로서 ECS에 신규서비스를 배포하고 운영해볼 계획입니다. 그럼 이제 시작해보겠습니다.



---




*   `시나리오`
*   `ECS에 대한 사전 조사`
*   `Cloud9 개발환경 설정 및 실습 준비하기`
*   `ECS 웹 콘솔에서 배포`
*   `배포 자동화`
*   `모니터링`
*   `오토 스케일링`
*   `정리`



---



```


```



## 1. 시나리오

앞서 이야기했듯 우리는 가상의 회사인 Petclinic 개발팀의 일원이 됩니다. Petclinic 서비스는 동물병원 관련한 웹 서비스입니다. 회사는 싱가포르에 있고 개발팀은 3명으로 프론트앤드 개발자 한명, 앱 개발자 한명, 서버 개발자 한명으로 구성되어있습니다. 우리의 역할은 서버개발자입니다. 혼자서 개발도 하고 배포도 하고 운영도 해야하는 상황이죠.

이제 어느 정도 개발을 마치고 스프링 부트 앱을 배포해 보려고 합니다. 회의를 통해서 EC2 기반의 AWS ECS를 이용하여 서비스를 배포하기로 결정했습니다. 해야할 일은 다음과 같습니다.



*   ECS를 이용한 배포
*   CodeBuild와 CodePipeline을 이요한 CI/CD
*   CloudWatch를 이용한 모니터링
*   서비스 및 ECS 인스턴스 오토 스케일링



<p id="gdcalert1" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/AWSKRUG-container0.png). Store image on your image server and adjust path/filename if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert2">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/AWSKRUG-container0.png "image_tooltip")


그리고 미리 준비해야할 것들은 다음과 같습니다.



*   Amazon webservice 계정 (루트유저 권장)
*   Github 계정
*   Dockerhub 계정


## 2. ECS에 대한 사전 조사

본격적으로 작업을 시작하기 전에 개념적으로 공부를 먼저 하려고 합니다. ECS가 어떤 역할을 하는지 그리고 어떤 개념들이 있는지 확인해보겠습니다.


### 2.1 ECS의 정의

ECS 홈페이지에 기술된 정의입니다.

" Amazon Elastic Container Service(ECS)는 확장성이 뛰어난 고성능 컨테이너 오케스트레이션 서비스로서, Docker 컨테이너를 지원하며 AWS에서 컨테이너식 애플리케이션을 쉽게 실행하고 확장 및 축소할 수 있습니다.

Amazon ECS를 사용하면 자체 컨테이너 오케스트레이션 소프트웨어를 설치하고 운영할 필요가 없으며, 가상 머신의 클러스터를 관리 및 확장하거나 해당 가상 머신에서 컨테이너를 예약하지 않아도 됩니다."

이해가 잘 안갑니다. 용어들을 정리하면서 개념을 잡아보겠습니다.


### 2.2 ECS의 용어 정리

작업 정의(Task Definition)에 대해서 먼저 설명하려고 합니다. 작업 정의는 실제 배포가 될 컨테이너들과 역할, 필요한 자원 등에 대한 정의입니다. 이 정의대로 실행이 된 프로그램 묶음을 작업(Task)이라고 합니다. 작업은 클러스터(Cluster)가 가지고 있는 컴퓨팅 자원 내 에서 실행됩니다. EC2 기반의 ECS라고 한다면 클러스터는 EC2 인스턴스들을 가지고 있습니다. Fargate라고 한다면 클러스터는 사용자 입장에서 논리적인 집합이 됩니다. 그렇게 작업은 클러스터 내에서 실행이 되는데 일반적으로 그 실행의 주체는 서비스(Service)입니다. 서비스는 작업을 어떤 정책과 규칙으로 실행할지에 대한 정의를 가지고 있습니다. 작업들을 어떻게 연결해서 외부로 공개할지(로드밸런싱), 작업들을 어떤 규칙에 의해서 늘이고 줄일지 (오토스케일링), 서비스 업데이트 시에 몇 퍼센트의 기존 작업을 종료하고 새로운 작업을 시작할지 등을 정의하고 있습니다.

정리하면, 작업 정의는 실행될 프로그램에 대한 정의이고 작업은 실행된 프로그램이며, 작업은 클러스터 내에서 실행되며, 작업은 서비스가 실행합니다. 쉽게 이해가 가지 않을 것입니다. 이제부터 실제로 해보면서 더 깊게 알아보겠습니다.


## 3. Cloud9 개발환경 설정 및 실습 준비하기

원활한 진행을 위해서 AWS의 Cloud9이라는 웹기반의 IDE에서 실습을 진행합니다. 그 이유는 일관된 환경 안에서 실습을 진행함으로써 불필요한 예외상황을 방지하기 위해서 입니다. 그런데 현재(2018년 9월) 기준으로 Cloud9은 [아시아 태평양 (싱가포르)](https://ap-southeast-1.console.aws.amazon.com/cloud9/home?region=ap-southeast-1), [미국 동부 (버지니아 북부)](https://console.aws.amazon.com/cloud9/home?region=us-east-1), [미국 동부 (오하이오)](https://us-east-2.console.aws.amazon.com/cloud9/home?region=us-east-2), [EU (아일랜드)](https://eu-west-1.console.aws.amazon.com/cloud9/home?region=eu-west-1), [미국 서부 (오레곤)](https://us-west-2.console.aws.amazon.com/cloud9/home?region=us-west-2) 리전에서만 사용할 수 있습니다. 가장 가까운 싱가포르 리전의 cloud9 메인 페이지에 접속해 보겠습니다. 


### 3.1 Cloud9 환경 만들기



1.  우측에 있는 'Create environment' 버튼을 클릭합니다.
1.  생성할 인스턴스의 이름을 'petclinic-cloud9'이라고 입력합니다. 설명(Description)은 생략합니다.

	<그림 1-3-1>


    

<p id="gdcalert2" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/AWSKRUG-container1.png). Store image on your image server and adjust path/filename if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert3">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/AWSKRUG-container1.png "image_tooltip")




1.  Environment type을 Create a new instance for environment (EC2)로 선택합니다. 새로운 인스턴스를 실행하고 거기에서 Cloud9 환경을 만들겠다는 의미입니다. Instance type은 t2.micro로 선택합니다. 나머지 설정은 모두 그대로 둡니다.

	<그림 1-3-2>


    

<p id="gdcalert3" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/AWSKRUG-container2.png). Store image on your image server and adjust path/filename if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert4">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/AWSKRUG-container2.png "image_tooltip")




1.  Review 페이지를 확인하고 'Create environment' 버튼을 클릭합니다. 조금 기다리시면 Cloud9 개발 환경을 만날 수 있습니다.

	

	<그림 1-3-3>



<p id="gdcalert4" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/AWSKRUG-container3.png). Store image on your image server and adjust path/filename if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert5">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/AWSKRUG-container3.png "image_tooltip")




1.  Cloud9 EC2 인스턴스에 대한 보안그룹을 설정합니다. Cloud9 환경에서 서버를 띄우고 내 로컬에서 확인하기 위해서 입니다. 백앤드 서버 앱의 경우는 9460 포트를 열고 프론트 앤드 개발 서버의 경우는 19460 포트를 열어둡니다.

    22번 포트도 위치무관으로 열어둔다. 브라우저에서 Cloud9에 접속할 때 필요한 설정입니다.


    <그림 1-3-4>


    

<p id="gdcalert5" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/AWSKRUG-container4.png). Store image on your image server and adjust path/filename if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert6">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/AWSKRUG-container4.png "image_tooltip")



이제 Cloud9의 개발환경을 구축하는 것은  완료되었습니다. 


### 3.2 필요한 도구 설치

다음은 필요한 도구들을 설치할 시간입니다. Cloud9 페이지 하단에 있는 터미널에서 주어진 명령어를 차례대로 실행합니다.



*   Git 설치 : Cloud9에 이미 설치되어 있습니다.
*   Docker 설치 : Cloud9에 이미 설치되어 있습니다.
*   Java8 설치 

    Cloud9에는 Java7이 기본적으로 설치되어 있습니다. 간단한 cli 명령을 통해서 Java8로 변경합니다.


    ```
# upgrade java8
sudo yum install -y java-1.8.0-openjdk-devel.x86_64
sudo /usr/sbin/alternatives --config java
2     	
sudo yum remove -y java-1.7.0-openjdk
javac -version
```


*   aws cli 설치 : Cloud9에 이미 설치되어 있습니다.
*   ecs-cli 설치

    ```
sudo curl -o /usr/local/bin/ecs-cli https://s3.amazonaws.com/amazon-ecs-cli/ecs-cli-linux-amd64-latest
sudo chmod +x /usr/local/bin/ecs-cli
ecs-cli --version
```


*   jq 설치

    터미널에서 aws cli를 사용하면 json 형식의 결과를 표준출력으로 확인할 수 있습니다. jq는 json 형태의 표준 출력 결과를 이용하는 쉘스크립트를 작성하기 위해서 필요한 도구입니다.


    ```
sudo yum -y install jq
```




### 3.3Git 설정 및 코드 내려받기

도구 설치를 완료했다면 git 설정을 하고 소스코드를 내려받을 차례입니다.


##### Git 설정

아래 명령어를 Cloud9 터미널에서 차례대로 실행합니다. 자신의 github 계정의 이름과 이메일로 변경하여 실행합니다.


```
git config --global user.name {your-github-name}
git config --global user.email {your-github-email}
```



##### 저장소 Fork

예제 코드가 저장되어 있는 github의 저장소로 이동하여 자신의 계정으로 Fork를 합니다.



*   backend repository : [https://github.com/voyagerwoo/petclinic-rest](https://github.com/voyagerwoo/petclinic-rest)
*   frontend repository : [https://github.com/voyagerwoo/petclinic-front](https://github.com/voyagerwoo/petclinic-front)


##### 코드 내려받기

자신의 계정의 저장소에서 코드를 내려받습니다.


```
git clone https://github.com/{your-github-name}/petclinic-rest
git clone https://github.com/{your-github-name}/petclinic-front
```



### 3.4 테스트 해보기

Cloud9에서 각 서비스들을 실행해서 브라우저를 통해서 확인해보겠습니다. Cloud9에서 원격으로 실행한 것이므로 확인도 Cloud9의 공개 IP를 가지고 확인합니다.


```
cd petclinic-rest
./mvnw spring-boot:run
```


위 명령어를 실행하여 백앤드 서비스를 실행합니다. 메이븐을 통해서 참조하고 있는 라이브러리를 모두 다운로드하기 때문에 5분 정도 소요됩니다. 한번 다운로드하고 나면 또 다운받지는 않기 때문에 그 이후에 다시 위 명령어로 실행할 경우 20초 정도 소요됩니다. Cloud9 EC2 인스턴스의 공개 IP에 9460 포트를 붙여서 브라우저를 통해서 확인해봅니다. 아래 주소를 참고하여 확인해보세요.

http://{cloud9-ec2-ip}:9460/actuator/health


```
cd ../petclinic-front
npm install
npm start
```


위 명령어를 실행하여 프론트앤드 서비스를 실행합니다. 아래 주소를 참고하여 브라우저에서 확인해보세요.

http://{cloud9-ec2-ip}:19460

이제 준비는 모두 끝났습니다. 실제로 ECS 인프라에 서비스를 배포해보겠습니다.


## 4 ECS 웹 콘솔에서 배포

petclinic-rest라는 스프링 부트로 만들어진 백앤드 서비스를 배포해보겠습니다. 프로젝트에 이미 도커파일을 통해서 도커 이미지가 정의가 되어있습니다. 도커 이미지를 만들고 만들어진 이미지를 도커 레지스트리에 푸시하고, ECS에서 그 이미지를 바탕으로 작업을 정의해서 서비스를 배포하는 순서로 진행됩니다. 지금부터 하나하나 진행해보겠습니다.

실습은 싱가포르 리전에서 진행되며 링크들은 모두 싱가포르 리전으로 연결됩니다.


### 4.1 [ECR(Elastic Container Registry) 만들기](https://ap-southeast-1.console.aws.amazon.com/ecs/home?region=ap-southeast-1#/repositories/create/new)

도커 이미지를 저장할 레지스트리를 만들어보겠습니다. ECS 콘솔로 이동하여 우측에서 리포지토리(Repository)를 클릭합니다. 만약 리포지토리가 없으면 시작하기 버튼을 클릭하고 있으면 리포지토리 생성을 클릭합니다.

리포지토리 이름에 'petclinic-rest'라고 입력하고 다음 단계를 클릭합니다. 푸시 명령 관련한 스크립트를 확인하고 완료를 누르면 레포지토리 생성이 완료 됩니다. 푸시 명령은 '푸시 명령 보기' 버튼을 통해서 언제든 다시 확인할 수 있습니다.


### 4.2 ECR에 도커이미지 푸시하기

Cloud9 에서 스프링 부트 앱을 빌드하고 결과물을 가지고 컨테이너로 실행 가능한 도커 이미지를 만듭니다. 명령어를 하나 하나 실행해가며 빌드하고 이미지를 레지스트리에 등록해보겠습니다.


```
cd petclinic-rest
./mvnw clean package
docker build -f src/main/docker/Dockerfile -t petclinic-rest .
```


이 작업을 통해서 petclinic-rest라는 도커 이미지가 만들어졌습니다. 도커 이미지가 잘 만들어졌는지 테스트해봅니다. 


```
docker run -it --rm -p 9460:9460 petclinic-rest
```


아까와 같은 방식으로 브라우저에서 테스트합니다. 잘 동작한다면 이번에는 이미지를 이전 단계에서 만든 리포지토리에 푸시해보겠습니다. 리포지토리 주소를 ECR 웹 콘솔 화면에서 복사해둡니다. 아니면 다음 명령어를 실행하여 확인할 수 있습니다.


```
aws ecr describe-repositories --repository-name petclinic-rest
```



```
도커의 tag 명령어를 통해서 기존의 이미지를 리포지토리 주소로 이름을 지어 줍니다. 그 이름으로 푸시하게 되면 리포지토리에 등록됩니다. jq 명령어를 통해서 리포지토리 주소만 가져옵니다. 그리고 그 주소를 가지고 태깅합니다.



```
REPOSITORY_URI=`aws ecr describe-repositories --repository-name petclinic-rest  | jq -r ".repositories[0].repositoryUri"`
docker tag petclinic-rest:latest ${REPOSITORY_URI}:latest
```



```
이제 docker login 명령어를 통해서 ECR에 푸시할 수 있는 권한을 획득하고 푸시 명령어를 수행하면 ECR 리포지토리에 등록됩니다.



```
DOCKER_LOGIN=`aws ecr get-login --no-include-email`
${DOCKER_LOGIN}

docker push ${REPOSITORY_URI}:latest
```



```
ECR 웹 콘솔에서 등록이 잘 되었는지 확인해봅니다.






<p id="gdcalert6" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/AWSKRUG-container5.png). Store image on your image server and adjust path/filename if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert7">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/AWSKRUG-container5.png "image_tooltip")
```



### 4.3 [보안 그룹 설정](https://ap-southeast-1.console.aws.amazon.com/ec2/v2/home?region=ap-southeast-1#SecurityGroups:sort=groupId) 및 [키페어 생성](https://ap-southeast-1.console.aws.amazon.com/ec2/v2/home?region=ap-southeast-1#KeyPairs:sort=keyName)

ECS 관련된 보안 그룹을 미리 만들어둡니다. 먼저 ECS 내부의 네트워크 흐름을 파악하는 것이 필요합니다. 



<p id="gdcalert7" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/AWSKRUG-container6.png). Store image on your image server and adjust path/filename if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert8">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/AWSKRUG-container6.png "image_tooltip")


서비스는 ALB(Application Load Balancer)를 통해서 외부로 노출됩니다. ALB가 ECS 인스턴스의 특정 포트를 통해 서비스에 접속합니다.  따라서 ALB의 보안 그룹은 웹서비스를 위해서 인바운드로 80포트를 열어둡니다. ALB 보안 그룹 이름은 'petclinic-rest-alb-sg'라고 입력합니다.



<p id="gdcalert8" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/AWSKRUG-container7.png). Store image on your image server and adjust path/filename if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert9">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/AWSKRUG-container7.png "image_tooltip")


그리고 ECS 인스턴스의 보안 그룹은 ALB 보안 그룹으로 들어오는 인바운드 규칙은 전체 포트를 열어둡니다. 그리고 ssh 접속이 가능하도록 22번 포트도 열어둡니다. ECS 인스턴스 보안 그룹 이름은 'petclinic-rest-ecs-instance-sg'라고 입력합니다.



<p id="gdcalert9" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/AWSKRUG-container8.png). Store image on your image server and adjust path/filename if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert10">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/AWSKRUG-container8.png "image_tooltip")


보안 그룹 설정을 마치면 ECS 인스턴스로 직접 ssh 접속을 할 수 있도록 키페어를 생성해둡니다. 키페어 이름은 'petclinic'이라고 입력합니다. 



<p id="gdcalert10" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/AWSKRUG-container9.png). Store image on your image server and adjust path/filename if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert11">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/AWSKRUG-container9.png "image_tooltip")



### 4.4 로드밸런서 생성

ECS 인스턴스들을 외부로 연결해 줄 로드밸런서를 미리 만들어 둡니다. 이름은 'petclinic-rest-alb'라고 입력합니다. 인터넷 연결로 선택하고 주소 유형은 ipv4로 선택합니다. 리스너는 HTTP로 선택합니다.



<p id="gdcalert11" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/AWSKRUG-container10.png). Store image on your image server and adjust path/filename if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert12">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/AWSKRUG-container10.png "image_tooltip")




<p id="gdcalert12" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/AWSKRUG-container11.png). Store image on your image server and adjust path/filename if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert13">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/AWSKRUG-container11.png "image_tooltip")


보안 설정 구성은 HTTP를 선택했으므로 무시하고 넘어갑니다. 



<p id="gdcalert13" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/AWSKRUG-container12.png). Store image on your image server and adjust path/filename if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert14">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/AWSKRUG-container12.png "image_tooltip")


보안 그룹은 미리 만들어둔 'petclinic-rest-alb-sg'를 선택합니다.



<p id="gdcalert14" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/AWSKRUG-container13.png). Store image on your image server and adjust path/filename if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert15">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/AWSKRUG-container13.png "image_tooltip")


대상 그룹을 만들어서 라우팅 구성을 합니다. 새 대상 그룹을 선택하고 이름은 'petclinic-rest-target'으로 입력합니다. 리스너는 http로 설정했으므로 프로토콜도 HTTP로 설정하고 포트도 80으로 입력합니다. 대상 유형은 ECS 인스턴스를 가리키기 때문에 instance를 선택합니다.

상태 검사는 spring-boot actuator에서 제공하는 health check 경로인 '/actuator/health'를 입력합니다.



<p id="gdcalert15" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/AWSKRUG-container14.png). Store image on your image server and adjust path/filename if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert16">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/AWSKRUG-container14.png "image_tooltip")


실제 대상 등록은 무시하고 넘어갑니다. 나중에 ECS 서비스 구성을 할때 설정합니다.



<p id="gdcalert16" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/AWSKRUG-container15.png). Store image on your image server and adjust path/filename if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert17">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/AWSKRUG-container15.png "image_tooltip")


구성 내용을 검토하고 이상이 없으면 생성합니다.



<p id="gdcalert17" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/AWSKRUG-container16.png). Store image on your image server and adjust path/filename if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert18">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/AWSKRUG-container16.png "image_tooltip")



### 4.5 ECS 클러스터 생성

이번에는 ECS 클러스터를 생성합니다. 배포에 필요한 자원들을 정의하고 등록합니다. ECS 웹 콘솔의 오른쪽 메뉴에서 클러스터를 클릭합니다. 클러스터 화면에서 [클러스터 생성](https://ap-southeast-1.console.aws.amazon.com/ecs/home?region=ap-southeast-1#/clusters/create/new) 버튼을 클릭합니다. 

첫번째 단계인 템플릿을 선택해야 합니다. 템플릿은 싱가포르 리전의 경우 세가지가 있습니다. 첫번째는 AWS Fargate라는 이름을 가진 템플릿입니다. 사용자는 EC2 자원에 대한 고민없이 클러스터를 만들고 컨테이너를 배포할 수 있습니다.  두번째는  EC2 Linux 인스턴스 기반에서 컨테이너를 배포하는 템플릿입니다. 세번째는 EC2 윈도우 인스턴스 기반에서 컨테이너를 배포하는 템플릿입니다. 첫번째는 현재(2018년 9월)기준으로 서울 리전에 없는 서비스입니다. 그래서 이번에는 두번째 'EC2 Linux + 네트워킹'를 선택해서 실습을 진행합니다.



<p id="gdcalert18" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/AWSKRUG-container17.png). Store image on your image server and adjust path/filename if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert19">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/AWSKRUG-container17.png "image_tooltip")


다음으로 클러스터 구성을 합니다. 클러스터 이름은 petclinic-rest-cluster 라고 입력합니다. 인스턴스 유형과 개수는 배포할 서비스가 필요한 자원의 크기를 고려하여 선택해야 합니다. 이번에는 인스턴스 유형은  t2.medium, 인스턴스 개수는 2개로 선택합니다. 그 이유는 이 후에 오토 스케일링 부분에서 자세히 설명할 예정입니다. keypair는 아까 만들어둔 petclinic으로 선택합니다.



<p id="gdcalert19" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/AWSKRUG-container18.png). Store image on your image server and adjust path/filename if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert20">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/AWSKRUG-container18.png "image_tooltip")




<p id="gdcalert20" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/AWSKRUG-container19.png). Store image on your image server and adjust path/filename if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert21">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/AWSKRUG-container19.png "image_tooltip")


네트워킹 설정을 할 차례입니다. 기존의 VPC와 서브넷을 선택합니다. 보안 그룹은 직전에 만들어둔 'petclinic-rest-ecs-instance-sg'를 선택합니다.



<p id="gdcalert21" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/AWSKRUG-container20.png). Store image on your image server and adjust path/filename if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert22">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/AWSKRUG-container20.png "image_tooltip")




<p id="gdcalert22" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/AWSKRUG-container21.png). Store image on your image server and adjust path/filename if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert23">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/AWSKRUG-container21.png "image_tooltip")


설정을 마치고 생성버튼을 누르게 되면 EC2 인스턴스를 실행하고 IAM 정책을 연결하고 CloudFormation을 통해서 필요한 리소스들을 생성합니다.


### 4.6 작업(Task) 정의

 ECS는 작업이라는 논리적인 단위로 배포하게 됩니다. 그래서 이번에는 작업을 정의해봅니다. 작업 정의에서는 작업의 일부가 될 컨테이너의 개수, 컨테이너가 사용할 리소스, 컨테이너 간 연결 방식, 컨테이너가 사용할 호스트 포트와 같은 애플리케이션 관련 컨테이너 정보를 지정합니다. 작업 정의는 각 앱의 상황에 맞게 컨테이너들을 잘 배치해야 합니다.

이번 실습에서 작업 정의는 간단합니다. 작업 내에는 스프링을 포함한 컨테이너 하나만 포함되어 있습니다. 그러면 시작해보겠습니다.

Fargate를 지원하는 리전의 경우에는 작업정의시에 아래처럼 시작 유형 호환성 선택을 합니다. 저희는 이번에 EC2 인스턴스 기반의 ECS를 실습하고 있으므로 EC2를 선택합니다.



<p id="gdcalert23" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/AWSKRUG-container22.png). Store image on your image server and adjust path/filename if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert24">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/AWSKRUG-container22.png "image_tooltip")


그 다음에는 작업 정의 이름을 'petclinic-rest-task'라고 입력합니다. 



<p id="gdcalert24" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/AWSKRUG-container23.png). Store image on your image server and adjust path/filename if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert25">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/AWSKRUG-container23.png "image_tooltip")


그 다음에는 작업크기를 설정합니다. EC2 유형에서는 인스턴스의 자원이 한정적이므로 작업 크기 입력이 선택사항이지만 Fargate 유형의 경우 어떤 인스턴스에서 작업으로 정의된 컨테이너들이 실행되는지 유저가 알 수 없으므로 작업크기를 한정해야합니다. 저는 이번에 작업 크기를 한정해보았습니다.



<p id="gdcalert25" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/AWSKRUG-container24.png). Store image on your image server and adjust path/filename if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert26">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/AWSKRUG-container24.png "image_tooltip")


그 다음에는 컨테이너를 추가합니다. 컨테이너 이름은 'petclinic-rest-app'이라고 하고 이미지 주소를 입력합니다. 이미지 주소를 모른다면 왼쪽 메뉴에 있는 리포지토리로 가서 확인합니다. 컨테이너의 메모리는 소프트 제한(soft limit)으로 625를 입력합니다. 포트 매핑의 경우 호스트 포트를 0으로 해주어야 합니다. 이렇게 해야 호스트의 포트가 동적으로 매핑이 되고 그 포트에 따라 로드밸런싱됩니다.

소프트 제한과 하드 제한 참고 링크 : [https://docs.docker.com/config/containers/resource_constraints/](https://docs.docker.com/config/containers/resource_constraints/)

ECS 동적 포트 매핑 참고 링크: [https://aws.amazon.com/ko/premiumsupport/knowledge-center/dynamic-port-mapping-ecs/](https://aws.amazon.com/ko/premiumsupport/knowledge-center/dynamic-port-mapping-ecs/)



<p id="gdcalert26" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/AWSKRUG-container25.png). Store image on your image server and adjust path/filename if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert27">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/AWSKRUG-container25.png "image_tooltip")


컨테이너를 추가하게 되면 다음처럼 메모리와 CPU 할당이 보여집니다. 



<p id="gdcalert27" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/AWSKRUG-container26.png). Store image on your image server and adjust path/filename if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert28">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/AWSKRUG-container26.png "image_tooltip")


그리고 제약은 아직 없으므로 무시하고 생성합니다.



<p id="gdcalert28" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/AWSKRUG-container27.png). Store image on your image server and adjust path/filename if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert29">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/AWSKRUG-container27.png "image_tooltip")


이렇게 작업 정의가 완료되었습니다. 

작업 정의 완료 되면 그 작업을 바로 EC2 인스턴스에서 실행해 볼 수 있습니다. 클러스터를 선택하고 작업탭에서 '새 작업 실행'이라는 버튼을 클릭합니다. 



<p id="gdcalert29" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/AWSKRUG-container28.png). Store image on your image server and adjust path/filename if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert30">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/AWSKRUG-container28.png "image_tooltip")


그리고 시작 유형을 EC2로 설정하고 작업 정의와 클러스터명, 작업 개수를 입력합니다. 작업 개수를 2로 입력하는 이유는 현재 인스턴스가 2개이기 때문입니다.



<p id="gdcalert30" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/AWSKRUG-container29.png). Store image on your image server and adjust path/filename if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert31">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/AWSKRUG-container29.png "image_tooltip")


해당 인스턴스에 ssh로 접속하여 확인해보면 컨테이너가 실행됨을 확인할 수 있습니다.



<p id="gdcalert31" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/AWSKRUG-container30.png). Store image on your image server and adjust path/filename if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert32">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/AWSKRUG-container30.png "image_tooltip")


그러나 이것은 아직 외부로 노출되지는 않았습니다. 보안그룹상 해당 인스턴스는 petclinc-rest-alb-sg 보안 그룹을 가진 서비스 즉, 로드밸런서에서만 접근이 가능합니다. 해당 인스턴스의 보안그룹을 수정하여 접근할 수는 있겠지만 이는 정상적인 방법은 아닙니다. 이제 서비스를 생성하고 서비스 내에서 작업을 배포하는 것을 통해서 정상적인 서비스 배포를 진행해보겠습니다.


### 4.7 서비스(Service) 생성 및 배포

ECS 클러스터에서 지정된 수의 작업을 실행하고 관리할 수 있습니다. 그 관리 주체를 서비스라고 합니다. 또한 서비스를 통해서 컨테이너들을 상태 검사(health check), 로드 밸런싱, 오토 스케일링을 할 수 있습니다. 

서비스를 생성해보겠습니다. 클러스터를 선택하고 서비스탭에서 생성 버튼을 누릅니다.



<p id="gdcalert32" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/AWSKRUG-container31.png). Store image on your image server and adjust path/filename if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert33">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/AWSKRUG-container31.png "image_tooltip")


이제 서비스를 구성합니다. 시작 유형은 ECS를 선택합니다. 작업 정의는 지난 번에 정의했던 최신 버전으로 선택합니다. (저는 두 번의 실수 때문에 리비전이 3입니다.) 클러스터를 선택하고 서비스 이름은 'petclinic-rest-service'라고 입력합니다. 서비스 유형은 REPLICA(기본값)를 선택합니다. 작업 개수는 인스턴스 개수인 2개로 맞춥니다. EC2 인스턴스가 감당할 수 있을 만큼 작업 개수를 선택할 수 있지만 저는 우선 2개로 정했습니다. 

컨테이너가 죽는 장애라던지 서비스 업데이트 같은 부분에 있어서 중요한 숫자가 '최소 정상 상태 백분율'과 '최대 백분율'입니다. 최소 정상 상태 백분율을 배포 과정에서 실행 중인 작업 개수의 하한선을 백분율로 나타낸 것을 의미합니다. 그 백분율은 서비스의 작업 개수에 대한 백분율입니다. 최대 백분율은 배포 과정에서 실행중인 작업 개수의 상한선을 백분율로 나타낸 것이며 이 또한 서비스의 작업 개수에 대한 백분율입니다. 예를 들어서 작업 개수가 2개이고 최소 정상 상태 백분율이 50이고 최대 백분율이 100이면 배포 과정에서 작업이 하나가 죽어도 정상상태입니다. 그렇기 때문에 두 작업 중 하나를 먼저 종료하고 새로운 작업을 배포하고, 작업 하나가 완료되면 다시 나머지 하나를 종료하고 업데이트 하는 방식으로 서비스 중단 없이 배포가 가능합니다. 만약 작업개수가 2개이고 최소 정상 상태 백분율이 100 최대 백분율이 200이라면 현재 실행중인 서비스를 종료하지 않고 새로운 작업들을 2개 미리 실행한 후에 완료가 되면 이전 두 작업을 종료합니다. 배포 과정 중에 4개의 작업이 실행되는 것이죠. 

시작유형이 EC2인 경우에 이런 백분율은 인스턴스의 자원과 작업이 필요한 자원을 잘 계산해서 설정해야 합니다. 



<p id="gdcalert33" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/AWSKRUG-container32.png). Store image on your image server and adjust path/filename if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert34">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/AWSKRUG-container32.png "image_tooltip")


상태 검사 유예 시간을 입력하기 전에 로드 밸런서를 선택합니다. 이전 단계에서 만들었던 로드 밸런서를 사용합니다. 그 다음 상태 검사 유예 기간을 60으로 입력합니다. 상태 검사 유예 기간은 로드 밸런서가 실행 중인 작업이 실행되고 나서 상태 검사(health check)를 하기까지 유예하는 시간입니다. 60초로 설정할 경우 작업이 시작된 후 60초 뒤에 상태 검사를 하고 만약 healthy이면 해당 작업을 로드 밸런싱하게 되고 unhealthy하게 되면 해당 작업을 종료 후에 다시 작업을 실행합니다. 만약 설정에 문제가 있어서 계속 unhealthy 상태가 되면 서비스는 끊임 없이 작업을 죽이고 살리는 일을 반복합니다. 



<p id="gdcalert34" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/AWSKRUG-container33.png). Store image on your image server and adjust path/filename if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert35">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/AWSKRUG-container33.png "image_tooltip")




<p id="gdcalert35" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/AWSKRUG-container34.png). Store image on your image server and adjust path/filename if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert36">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/AWSKRUG-container34.png "image_tooltip")


로드 밸런싱할 컨테이너를 선택합니다. 우리의 작업 정의에는 컨테이너가 하나 뿐이기 때문에 그 컨테이너를 선택하고 ELB 추가 버튼을 누릅니다. 그러면 아래 처럼 화면이 바뀌게 됩니다. 이 부분은 로드 밸런서 입장에서 컨테이너를 대상 그룹에 추가하는 작업입니다. 대상 그룹에 이미 관련된 내용이 정의가 되어 있으므로 대상 그룹만 선택하게 되면 경로 패턴이나 상태 확인 경로가 자동으로 입력됩니다.

로드 밸런서가 상태



<p id="gdcalert36" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/AWSKRUG-container35.png). Store image on your image server and adjust path/filename if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert37">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/AWSKRUG-container35.png "image_tooltip")




<p id="gdcalert37" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/AWSKRUG-container36.png). Store image on your image server and adjust path/filename if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert38">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/AWSKRUG-container36.png "image_tooltip")


오토 스케일링은 지금은 생략하고 다음 단계로 갑니다.



<p id="gdcalert38" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/AWSKRUG-container37.png). Store image on your image server and adjust path/filename if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert39">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/AWSKRUG-container37.png "image_tooltip")


검토를 통해서 입력값들을 확인하고 문제가 없다면 서비스 생성 버튼을 누릅니다. 그러면 서비스를 생성하고 서비스가 실행 주체로서 작업을 실행하게 됩니다. ECS 화면에서 만들어진 서비스를 클릭해서 서비스 화면을 확인해보면 서비스에 대한 내용을 확인할 수 있습니다. 서비스 화면에서 이벤트 탭을 확인해서 문제가 있는지 없는 지 확인할 수 있습니다. 문제가 없다면 배포는 완료입니다.



<p id="gdcalert39" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/AWSKRUG-container38.png). Store image on your image server and adjust path/filename if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert40">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/AWSKRUG-container38.png "image_tooltip")


로드 밸런서가 컨테이너 상태 검사를 하는 부분은 EC2 콘솔 > 대상 그룹 > 하단 화면의 대상 탭에서 확인할 수 있습니다.  



<p id="gdcalert40" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/AWSKRUG-container39.png). Store image on your image server and adjust path/filename if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert41">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/AWSKRUG-container39.png "image_tooltip")


이제 서비스가 인터넷에 공개되었습니다. 브라우저에서 확인해보겠습니다. EC2 콘솔 > 로드밸런서 > 하단 화면의 설명탭에서 DNS 이름을 복사합니다.



<p id="gdcalert41" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/AWSKRUG-container40.png). Store image on your image server and adjust path/filename if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert42">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/AWSKRUG-container40.png "image_tooltip")


상태체크 URL을 통해서 확인해보겠습니다. DNS이름 뒤에 '/actuator/health'를 브라우저 주소창에 입력합니다. JSON 형태로 status : "UP" 이라고 나오면 정상입니다.



<p id="gdcalert42" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/AWSKRUG-container41.png). Store image on your image server and adjust path/filename if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert43">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/AWSKRUG-container41.png "image_tooltip")


처음에 실습을 따라하다보면 상태가 unhealthy가 되는 경우가 왕왕 있습니다. 개인적으로 했던 두가지 실수는 대상그룹을 설정할 때 상태 확인 경로에 오타가 났을 경우, 상태 검사 유예 시간을 너무 짧게 주었을 때 입니다. 이런 실수들은 나중에 나중에 도움이 많이 됩니다.



<p id="gdcalert43" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/AWSKRUG-container42.png). Store image on your image server and adjust path/filename if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert44">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/AWSKRUG-container42.png "image_tooltip")



### 4.8 서비스 업데이트

이번에는 서비스 업데이트를 한번 해보겠습니다. 서비스 업데이트 테스트를 위해서 전용 엔드포인트를 만들어두었습니다. 아까 복사해둔 로드밸런서 DNS 이름에 '/test/updste'를 추가해서 브라우저에 입력해봅니다. 



<p id="gdcalert44" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/AWSKRUG-container43.png). Store image on your image server and adjust path/filename if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert45">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/AWSKRUG-container43.png "image_tooltip")


코드를 수정해서 응답의 문구를 수정해보겠습니다. cloud9에서 petclinic-rest > src > main > java > vw.demo.petclinic > interfaces > tests > UpdateTestController.java 파일을 수정합니다. 한글로 바꿔보겠습니다. 



<p id="gdcalert45" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/AWSKRUG-container44.png). Store image on your image server and adjust path/filename if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert46">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/AWSKRUG-container44.png "image_tooltip")


코드를 수정합니다. 그리고 도커 이미지를 빌드하고 3.2.2와 같은 방식으로 ECR에 도커 이미지를 푸시합니다. 


```
cd petclinic-rest
./mvnw clean package
docker build -f src/main/docker/Dockerfile -t petclinic-rest .
REPOSITORY_URI=`aws ecr describe-repositories --repository-name petclinic-rest  | jq -r ".repositories[0].repositoryUri"`
docker tag petclinic-rest:latest ${REPOSITORY_URI}:latest
DOCKER_LOGIN=`aws ecr get-login --no-include-email`
${DOCKER_LOGIN}
docker push ${REPOSITORY_URI}:latest
```




<p id="gdcalert46" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/AWSKRUG-container45.png). Store image on your image server and adjust path/filename if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert47">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/AWSKRUG-container45.png "image_tooltip")


정상적으로 푸시가 되었다면 ECR 페이지에서 확인할 수 있습니다. 이제 서비스 업데이트를 통해서 수정본을 반영해 보겠습니다. 클러스터를 선택하고 petclinic-rest-service를 클릭하여 서비스 화면에 진입합니다. 우측 상단에 업데이트라는 버튼을 클릭하면 서비스 구성 화면이 나옵니다. 작업 정의는 바뀐게 없으므로 따로 수정하지 않습니다. 도커 이미지가 병경되었음에도 작업 정의가 바뀌지 않은 것은 도커 이미지의 이름이 바뀌지 않았기 때문입니다. 그래서 새 배포 적용(Force new deployment)을 선택해서 강제로 이미지가 바뀌도록 해야합니다. 나머지도 모두 그대로 둡니다. 단계 4까지 스킵하고 서비스 업데이트 버튼을 누릅니다.



<p id="gdcalert47" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/AWSKRUG-container46.png). Store image on your image server and adjust path/filename if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert48">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/AWSKRUG-container46.png "image_tooltip")


ECS 서비스의 이벤트 탭과 EC2 > 대상그룹 하단의 대상 탭 을 통해서 진행상황을 확인합니다. 



<p id="gdcalert48" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/AWSKRUG-container47.png). Store image on your image server and adjust path/filename if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert49">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/AWSKRUG-container47.png "image_tooltip")


이벤트는 기본적으로 최신순입니다. 아래 내용부터 메시지를 내용을 확인해보겠습니다. 

우선 서비스가 새로운 작업 두개를 실행시켰습니다. 그리고 그 이후 타겟 그룹에 새로운 타겟(컨테이너)를 등록시킵니다. 새로운 타겟에 대한 상태 체크를 마친 뒤에 기존의 타겟을 제거합니다. 그 다음에 작업을 종료하는 일을 시작합니다. 타겟 그룹 속성에 있는 등록 취소 지연 시간(60초로 설정) 뒤에 작업을 종료합니다. 등록 취소 지연 시간은 서버가 현재까지 들어온 요청을 완료할 수 있도록 설정하는 시간입니다. 얼마 뒤에 안정적인 상태라는 메시지가 출력됩니다.

실제로 서비스가 수정이 반영되었는지 확인해보겠습니다. 



<p id="gdcalert49" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/AWSKRUG-container48.png). Store image on your image server and adjust path/filename if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert50">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/AWSKRUG-container48.png "image_tooltip")


변경이 되었습니다. 만약 도커 이미지의 이름이 변경되거나 새로운 이미지를 통해서 컨테이너를 추가하거나 여러가지 방법으로 작업 정의 자체가 변경 되었을 때는 서비스 업데이트할 때 변경된 작업 리비전을 입력해서 업데이트 하면 됩니다.


## 5. 빌드 및 배포 자동화

지금까지 우리가 직접 ECS 인스턴스에 서비스를 만들고 작업들을 배포했습니다. 수정 사항이 있을 때 같은 과정을 반복하게 됩니다. 이번에는 AWS의 CodeBuild와 CodePipeline을 이용해서 빌드 및 배포 자동화를 구축해보겠습니다.


### 5.0 maven 캐싱용 s3 버킷 만들기

준비해야할 것이 있습니다. 현재 우리가 배포해야할 스프링 부트 프로젝트는 메이븐 이라는 도구를 이용해서 의존된 라이브러리를 관리하고 빌드합니다. 관련된 라이브러리 등의 도구들이 매우 사이즈가 큰 편이며 매 빌드시에 새로 다운로드하게 되면 시간이 매우 오래 걸립니다. 그래서 캐싱용 저장소를 s3에 만들어 둡니다. S3 웹 콘솔로 이동해서 싱가포르 리전에 새로운 버킷을 하나 만듭니다. '{username}-codebuild-cache-store'라는 이름으로 버킷을 만듭니다. 버킷 이름은 AWS 리전 전체에서 중복이 되지 않습니다. 중복에 유의하여 이름을 짓습니다.



<p id="gdcalert50" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/AWSKRUG-container49.png). Store image on your image server and adjust path/filename if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert51">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/AWSKRUG-container49.png "image_tooltip")



### 5.1 CodeBuild 만들기

"AWS CodeBuild는 소스 코드를 컴파일하는 단계부터 테스트 실행 후 소프트웨어 패키지를 개발하여 배포하는 단계까지 마칠 수 있는 완전관리형의 지속적 통합 서비스입니다. CodeBuild를 사용하면 자체 빌드 서버를 프로비저닝, 관리 및 확장할 필요가 없습니다. CodeBuild는 지속적으로 확장되며 여러 빌드를 동시에 처리하기 때문에 빌드가 대기열에서 대기하지 않고 바로 처리됩니다."

우리는 CodeBuild를 통해서 깃헙 마스터 브랜치에 푸시가 되면 자동으로 스프링 프로젝트를 빌드하고 도커 이미지로 만든 다음 이미지를 ECR에 푸시하도록 할 것입니다.

우선 CodeBuild를 만들어보겠습니다. 입력할 내용이 많기 때문에 천천히 따라해보시기 바랍니다. 싱가포르 리전의 [CodeBuild 페이지](https://ap-southeast-1.console.aws.amazon.com/codebuild/home?region=ap-southeast-1)로 이동합니다. 프로젝트 만들기 버튼을 클릭하여 프로젝트 구성 화면으로 들어옵니다.

프로젝트 이름은 'petclinic-rest-build'라고 입력합니다. 소스 공급자는 GitHub입니다. 내 계정의 리포지토리 사용을 선택하고 GitHub과 연결합니다. 그 이후 3.1 준비 단계에서 fork 했던 petclinic-rest를 선택합니다. Webhook 체크박스를 체크하여 코드 변경이 빌드로 이어질 수 있게끔 연결해줍니다. 모든 코드 변경이 아닌 master 브랜치의 변경만이 빌드로 이어지게끔 필터를 설정합니다. (추후에 CodePipeline을 연결할 때 CodePipeline에서 Webhook을 받기 때문에 그 때는 이 설정을 끌 예정입니다.)



<p id="gdcalert51" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/AWSKRUG-container50.png). Store image on your image server and adjust path/filename if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert52">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/AWSKRUG-container50.png "image_tooltip")




<p id="gdcalert52" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/AWSKRUG-container51.png). Store image on your image server and adjust path/filename if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert53">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/AWSKRUG-container51.png "image_tooltip")


빌드 방법을 설정합니다. 빌드하는 환경을 설정하는데 운영체제는 우분투, 런타임은 자바로 설정합니다. 런타임 버전은 'openjdk8'입니다. 이번 빌드가 단순히 자바 패키징이 아닌 도커 이미지를 만드는 것이므로 '권한이 있음'에 꼭 체크해야 합니다. CodeBuild도 도커 이미지 내에서 빌드를 하게 되는데 도커 이미지 내에서 도커 이미지를 만들려면 해당 설정이 꼭 필요합니다.  빌드 사양(Build Spec)은 어떻게 빌드할지 정의하는 방법입니다. 우리는 기본값이 buildspec.yml을 사용하여 정의하였습니다.

빌드사양 작성방식 : [https://docs.aws.amazon.com/ko_kr/codebuild/latest/userguide/build-spec-ref.html](https://docs.aws.amazon.com/ko_kr/codebuild/latest/userguide/build-spec-ref.html)



<p id="gdcalert53" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/AWSKRUG-container52.png). Store image on your image server and adjust path/filename if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert54">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/AWSKRUG-container52.png "image_tooltip")


간단하게 현재 프로젝트의 buildspec 코드를 간단히 살펴보겠습니다. 크게 네가지 부분이 있습니다. 환경변수를 설정하는 env, 빌드 스크립트를 기술하는 phases, 빌드 산출물을 정의하는 artifacts, 그리고 캐시에 대해 설정하는 cache 부분이 있습니다. 

그중에서도 중요한 phases 부분은 또 세가지 부분으로 나누어져 있습니다. 첫번째는 빌드하기 전에 필요한 것을 준비하는 pre_build 단계입니다. json을 파싱하기 위해서 필요한 도구인 jq를 설치하고 ECR에 푸시하기 위해서 로그인을 합니다. 두번째는 build 단계입니다. 메이븐을 통해서 프로젝트를 패키징하고 패키징한 내용을 바탕으로 도커 이미지를 만들어 냅니다. 세번째는 빌드 후처리를 하는 post_build 단계입니다. aws cli를 통해서 'petclinic-rest'라는 이름을 가진 리포지토리 정보를 가져와서 jq를 통해서 URI를 추출합니다. 만들어진 도커 이미지를 추출한 URI로 태깅하고 푸시합니다. 그리고 작업 정의에서 ECS container 이름과 이미지 주소를 json형태의 파일로 만들어서 저장합니다. 

재미있는 부분은 스프링 부트에서 정말 편하게 사용하고 있는 maven wrapper를 사용하면 에러가 난다는 것입니다. 그래서 그냥 mvn 명령어로 빌드하였습니다.


```
version: 0.2
# build image : aws/codebuild/java:openjdk-8

env:
 variables:
   IMAGE_NAME: "petclinic-rest"

phases:
 pre_build:
   commands:
     - echo "Installing jq..."
     - curl -qL -o jq https://stedolan.github.io/jq/download/linux64/jq && chmod +x ./jq
     - echo "Logging in to Amazon ECR..."
     - DOCKER_LOGIN=`aws ecr get-login --no-include-email`
     - ${DOCKER_LOGIN}
 build:
   commands:
     - echo "Build started on `date`"
     - echo "Building the Docker image..."
     - mvn clean package
     - docker build -f src/main/docker/Dockerfile -t petclinic-rest .
 post_build:
   commands:
     - echo "Build completed on `date`"
     - echo "Pushing the Docker image..."
     - REPOSITORY_URI=`aws ecr describe-repositories --repository-name ${IMAGE_NAME} | ./jq -r ".repositories[0].repositoryUri"`
     - docker tag petclinic-rest:latest ${REPOSITORY_URI}:latest
     - docker push ${REPOSITORY_URI}:latest
     - printf '[{"name":"petclinic-rest-app","imageUri":"%s"}]' ${REPOSITORY_URI}:latest > imagedefinitions.json

artifacts:
   files: imagedefinitions.json

cache:
 paths:
   - '/root/.m2/**/*'
```


위에서 아티펙트는 정의했지만 현재는 사용하지 않기 때문에 아티팩트 없음을 선택합니다. 그리고 캐시는 직전에 만들어둔 S3 버킷 이름을 선택하고 접두사를 'petclinic-rest'라고 입력합니다. 이 버킷은 나중에 다른 프로젝트를 빌드할 때도 접두사만 바꿔주면 재사용할 수 있습니다.



<p id="gdcalert54" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/AWSKRUG-container53.png). Store image on your image server and adjust path/filename if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert55">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/AWSKRUG-container53.png "image_tooltip")




<p id="gdcalert55" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/AWSKRUG-container54.png). Store image on your image server and adjust path/filename if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert56">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/AWSKRUG-container54.png "image_tooltip")


로그를 CloudWatch에서 보고 싶다면 아래 처럼 체크하고 입력해줍니다.



<p id="gdcalert56" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/AWSKRUG-container55.png). Store image on your image server and adjust path/filename if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert57">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/AWSKRUG-container55.png "image_tooltip")


서비스의 역할은 새로 생성하도록 하고 이름을 기억해둡니다. 만들어진 바로 직후에 역할(Role)에게 ECR에 대한 권한을 부여해야하기 때문입니다.



<p id="gdcalert57" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/AWSKRUG-container56.png). Store image on your image server and adjust path/filename if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert58">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/AWSKRUG-container56.png "image_tooltip")


그러면 이제 CodeBuild를 만들 준비가 완료되었습니다. 계속을 눌러서 검수하고 생성합니다. 이제는 CodeBuild가 가진 역할에 ECR에 대한 접근 권한을 추가해야합니다. 그렇게 해야만 만들어진 도커 이미지를 ECR에 푸시할 수 있습니다. IAM 콘솔 화면에 들어가서 우측 메뉴에서 역할을 클릭합니다. 검색을 통해서 petclinic-rest-build의 역할을 찾습니다. 역할 이름을 클릭합니다.



<p id="gdcalert58" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/AWSKRUG-container57.png). Store image on your image server and adjust path/filename if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert59">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/AWSKRUG-container57.png "image_tooltip")


역할에 대한 정보가 나옵니다. 우측 상단에 있는 인라인 정책 추가 버튼을 클릭합니다.



<p id="gdcalert59" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/AWSKRUG-container58.png). Store image on your image server and adjust path/filename if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert60">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/AWSKRUG-container58.png "image_tooltip")


정책에 대한 JSON 에디터에서 다음의 JSON 코드를 입력합니다. ECR에 대한 권한을 부여하는 코드입니다. 


```
{
    "Version": "2012-10-17",
    "Statement": [
        {
            "Sid": "VisualEditor0",
            "Effect": "Allow",
            "Action": [
                "ecr:CompleteLayerUpload",
                "ecr:DescribeImages",
                "ecr:GetAuthorizationToken",
                "ecr:DescribeRepositories",
                "ecr:UploadLayerPart",
                "ecr:InitiateLayerUpload",
                "ecr:BatchCheckLayerAvailability",
                "ecr:PutImage"
            ],
            "Resource": "*"
        }
    ]
}
```


정책 검토 화면에서 이름을 'codebuild-ecr-policy'라고 입력합니다. 등록을 하게 되면 권한이 부여됩니다. 



<p id="gdcalert60" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/AWSKRUG-container59.png). Store image on your image server and adjust path/filename if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert61">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/AWSKRUG-container59.png "image_tooltip")


이제 빌드에 대한 모든 준비를 마쳤습니다. 빌드를 해보겠습니다. CodeBuild 웹 콘솔로 들어가서 우리가 만든 빌드 프로젝트를 클릭합니다. 두가지 방식으로 빌드를 할 수 있습니다. 첫번째는 GitHub에 코드 푸시를 통해서 하는 것입니다. 두번째는 빌드 프로젝트 화면에서 빌드시작 버튼을 누르는 것입니다. 저는 두번째 방식으로 빌드를 해보겠습니다. 



<p id="gdcalert61" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/AWSKRUG-container60.png). Store image on your image server and adjust path/filename if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert62">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/AWSKRUG-container60.png "image_tooltip")


빌드 시작 버튼을 누르게 되면 설정화면이 나오는데 기본값에 대한 수정없이 그냥 빌드를 시작합니다. 빌드 단계 세부 정보의 상태와 빌드 로그를 확인할 수 있습니다. 처음 하게 되면 5분 정도 시간이 소요됩니다. 그러나 두번째 부터는 1분 내외로 시간이 소요됩니다.



<p id="gdcalert62" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/AWSKRUG-container61.png). Store image on your image server and adjust path/filename if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert63">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/AWSKRUG-container61.png "image_tooltip")




<p id="gdcalert63" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/AWSKRUG-container62.png). Store image on your image server and adjust path/filename if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert64">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/AWSKRUG-container62.png "image_tooltip")


ECR 콘솔에서도 잘 반영이 되었는지 확인해봅니다. 다음 단계는 빌드가 되고 나서 수정사항이 자동으로 반영되도록 하는 것입니다.


### 5.3 CodePipeline 만들기

AWS CodeBuild는 말 그대로 빌드하고 빌드한 결과물을 어딘가에 저장하는 역할을 하고 있습니다. 그 이후 흐름은 CodePipeline이 진행합니다. 

"AWS CodePipeline은 빠르고 안정적인 애플리케이션 및 인프라 업데이트를 위해 릴리스 파이프라인을 자동화하는 데 도움이 되는 완전관리형 지속적 전달 서비스입니다. CodePipeline은 코드 변경이 발생할 때마다 사용자가 정의한 릴리스 모델을 기반으로 릴리스 프로세스의 빌드, 테스트 및 배포 단계를 자동화합니다."

우리는 CodePipeline을 통해서 소스가 변경되면 CodeBuild를 통해서 빌드하고 그 이후 ECS 작업을 업데이트 하도록 설정할 것입니다. AWS CodePipeline 웹 콘솔 화면으로 들어가서 시작하기 버튼을 누릅니다. 만약 만들어진 파이프라인이 있다면 파이프라인 생성 버튼을 누릅니다.



<p id="gdcalert64" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/AWSKRUG-container63.png). Store image on your image server and adjust path/filename if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert65">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/AWSKRUG-container63.png "image_tooltip")


파이프라인 생성을 시작합니다. 파이프 라인 이름은 'petclinic-rest-codepipeline'이라고 입력합니다. 



<p id="gdcalert65" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/AWSKRUG-container64.png). Store image on your image server and adjust path/filename if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert66">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/AWSKRUG-container64.png "image_tooltip")


그 다음 소스 공급자를 GitHub으로 지정하고 GitHub에 연결합니다. 만약 미리 연결이 되어있지 않다면 GitHub에 로그인하고 등록하는 과정을 진행합니다. 



<p id="gdcalert66" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/AWSKRUG-container65.png). Store image on your image server and adjust path/filename if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert67">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/AWSKRUG-container65.png "image_tooltip")


GitHub이 연결되었다면 리포지토리와 브랜치 정보를 입력합니다. 이제는 CodePipeline이 Webhook을 사용하여 변경을 감지하게 됩니다. 



<p id="gdcalert67" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/AWSKRUG-container66.png). Store image on your image server and adjust path/filename if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert68">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/AWSKRUG-container66.png "image_tooltip")


빌드 공급자는 AWS CodeBuild를 선택하고 이전 단계에서 만들었던 'petclinic-rest-build' 프로젝트를 입력합니다.



<p id="gdcalert68" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/AWSKRUG-container67.png). Store image on your image server and adjust path/filename if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert69">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/AWSKRUG-container67.png "image_tooltip")


배포에 대한 설정을 진행합니다. 배포 공급자는 Amazon ECS를 선택합니다. ECS의 클러스터 이름은 'petclinic-rest-cluster', 서비스 이름은 'petclinic-rest-service', 이미지 파일 이름은 buildspec.yml에서 정의했던 파일 명인 'imagedefinations.json'을 입력합니다. 간략하게 저 파일의 규칙과 역할을 설명하겠습니다. 


```
printf '[{"name":"petclinic-rest-app","imageUri":"%s"}]' ${REPOSITORY_URI}:latest > imagedefinitions.json
```


파일은 JSON 배열 내에 ECS 작업 정의에 기술된 컨테이너 명(name)과 도커 이미지의 주소(imageUri) 정보를 기술합니다. artifact 파일에 컨테이너 명이나 이미지 주소가 잘못 기술되어 있다면 CodePipeline의 배포 단계에서 에러가 발생합니다.



<p id="gdcalert69" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/AWSKRUG-container68.png). Store image on your image server and adjust path/filename if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert70">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/AWSKRUG-container68.png "image_tooltip")


그 다음 현재 만들고 있는 CodePipeline의 역할을 만들어서 입력합니다. 역할 만들기를 클릭하게 되면 역할을 만드는 화면이 나옵니다. 역할 이름은 자동으로 입력된 값으로 했습니다. 



<p id="gdcalert70" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/AWSKRUG-container69.png). Store image on your image server and adjust path/filename if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert71">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/AWSKRUG-container69.png "image_tooltip")




<p id="gdcalert71" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/AWSKRUG-container70.png). Store image on your image server and adjust path/filename if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert72">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/AWSKRUG-container70.png "image_tooltip")


이 작업을 모두 마치면 코드 파이프라인이 만들어지고 동작을 시작합니다. 전체 모두를 진행하는데 약 10분 정도 소요됩니다. 



<p id="gdcalert72" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/AWSKRUG-container71.png). Store image on your image server and adjust path/filename if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert73">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/AWSKRUG-container71.png "image_tooltip")


그리고 우리는 CodeBuild의 Webhook 설정을 꺼줘야합니다. 코드가 수정되었을 때 빌드를 두번씩 하게 됩니다. 왜냐하면 CodeBuild의 Webhook이 한번, CodePipeline이 한번, 이렇게 두번하기 때문입니다. CodeBuild 웹 콘솔에서 petclinic-rest-build를 선택하고 프로젝트 편집을 클릭합니다. 그리고 빌드 대상에서 Webhook 체크박스를 비워둡니다.



<p id="gdcalert73" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/AWSKRUG-container72.png). Store image on your image server and adjust path/filename if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert74">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/AWSKRUG-container72.png "image_tooltip")




<p id="gdcalert74" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/AWSKRUG-container73.png). Store image on your image server and adjust path/filename if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert75">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/AWSKRUG-container73.png "image_tooltip")


CodeBuild의 빌드 기록을 확인해보면 제출자, 빌드를 요청하는 주체가 Github Webhook, root, CodePipeline 이렇게 세 가지임을 확인할 수 있습니다. 기존에는 GitHub의 Webhook에 바로 반응했다면 이제는 Codpipeline에서 빌드하게 됩니다.



<p id="gdcalert75" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/AWSKRUG-container74.png). Store image on your image server and adjust path/filename if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert76">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/AWSKRUG-container74.png "image_tooltip")


문제가 없다면 아래처럼 CodePipeline이 정상적으로 동작하는 것을 확인할 수 있습니다.



<p id="gdcalert76" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/AWSKRUG-container75.png). Store image on your image server and adjust path/filename if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert77">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/AWSKRUG-container75.png "image_tooltip")



### 5.4 비정상인 소스 수정

 이번에는 비정상적으로 소스를 수정했을 경우에 CodePipeline이 어떻게 동작하는 지 확인해보겠습니다. 비정상적인 소스 수정은 여러가지가 있겠지만 이번에는 '작업 정의와 맞지 않은 아티펙트 작성'과 '테스트 실패'에 대해서 다뤄보겠습니다.

우선 작업 정의와 맞지 않은 아티펙트 작성입니다.

cloud9에서 petclinic-rest > buildspec.yml 파일을 엽니다. 30번째 라인에서 'petclinic-rest-app'을 'petclinic-rest'로 바꿔서 푸시해봅시다.



<p id="gdcalert77" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/AWSKRUG-container76.png). Store image on your image server and adjust path/filename if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert78">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/AWSKRUG-container76.png "image_tooltip")



```
git add buildspec.yml 
git commit -m "Test wrong ecs container name"
git push -u origin master
```


동작 중에는 커밋 메시지가 보입니다. 코드 반영이 시작 되고 몇분 뒤에 Staging 단계에서 실패하는 것을 확인할 수 있습니다. 세부정보를 클릭하면 구성이 못 되어있다는 메시지를 확인할 수 있습니다. 코드를 원상복구하고 다시 확인해봅니다. 



<p id="gdcalert78" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/AWSKRUG-container77.png). Store image on your image server and adjust path/filename if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert79">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/AWSKRUG-container77.png "image_tooltip")
 

<p id="gdcalert79" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/AWSKRUG-container78.png). Store image on your image server and adjust path/filename if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert80">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/AWSKRUG-container78.png "image_tooltip")


<p id="gdcalert80" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/AWSKRUG-container79.png). Store image on your image server and adjust path/filename if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert81">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/AWSKRUG-container79.png "image_tooltip")


두번째로 테스트가 실패하면 어떻게 동작하는 지 확인해보겠습니다. cloud9에서 petclinic-rest > src > test > java > vw.demo.petclinic > BlockingDeployTests.java 파일을 엽니다. 주석처리된 8~11번째 라인을 주석 해제합니다. 강제로 테스트가 실패하게 하는 코드입니다.



<p id="gdcalert81" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/AWSKRUG-container80.png). Store image on your image server and adjust path/filename if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert82">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/AWSKRUG-container80.png "image_tooltip")



```
git add src/test/java/vw/demo/petclinic/BlockingDeployTests.java
git commit -m "Test fail test code"
git push -u origin master
```


푸시와 함께 CodePipeline이 동작합니다. 이번에는 빌드 중에 실패했습니다. 기본적으로 메이븐으로 빌드할때 테스트 코드를 모두 실행해보고 빌드하는데 중간에 테스트 코드가 실패하면 메이븐 빌드도 실패하기 때문입니다. CodeBuild에서도 메이븐 빌드가 실패하였으므로 전체 빌드가 실패하는 것입니다. 



<p id="gdcalert82" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/AWSKRUG-container81.png). Store image on your image server and adjust path/filename if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert83">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/AWSKRUG-container81.png "image_tooltip")


다시 실패하는 테스트 코드를 주석처리 혹은 삭제하고 푸시합니다. 그리고 정상 동작하는 지 확인합니다.



<p id="gdcalert83" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/AWSKRUG-container82.png). Store image on your image server and adjust path/filename if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert84">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/AWSKRUG-container82.png "image_tooltip")



### 5.5 정상적인소스 수정

이번에는 정상적으로 코드를 수정하고 반영해보도록 하겠습니다. cloud9에서 petclinic-rest > src > main > java > vw.demo.petclinic > interfaces > tests > UpdateTestController.java 이 파일을 열어봅니다. 

이번에는 "동물병원 서비스 코드 파이프라인 업데이트 테스트."라고 문구를 수정해 보겠습니다. 수정을 마치고 코드를 푸시합니다.



<p id="gdcalert84" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/AWSKRUG-container83.png). Store image on your image server and adjust path/filename if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert85">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/AWSKRUG-container83.png "image_tooltip")



```
git add src/main/java/vw/demo/petclinic/interfaces/tests/UpdateTestController.java
git commit -m "Test Codepipeline update"
git push origin master
```


정상적으로 파이프라인이 동작했습니다. 



<p id="gdcalert85" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/AWSKRUG-container84.png). Store image on your image server and adjust path/filename if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert86">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/AWSKRUG-container84.png "image_tooltip")


브라우저를 통해서 반영이 되었는지 확인해봅시다. 



<p id="gdcalert86" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/AWSKRUG-container85.png). Store image on your image server and adjust path/filename if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert87">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/AWSKRUG-container85.png "image_tooltip")


지금까지의 작업으로 ECS 인프라를 클러스터를 구성하고 작업을 정의한 다음, 서비스를 생성하여 서비스를 통해서 작업을 배포하도록 설정했습니다. 또한 CodeBuild와 CodePipeline을 통해서 배포에 대해서도 자동화를 마쳤습니다. 다음에는 서비스 운영을 위한 모니터링과 오토스케일링에 대해서 다뤄보겠습니다.


## 6. 모니터링

ECS로 서비스를 운영하려면 모니터링이 필요합니다. 서비스 모니터링은 상당히 범위가 넓기 때문에 우선 이번에는 ECS 클러스터와 서비스의 지표를 확인하는 것에 대해서 알아보겠습니다. 


### 6.1 클러스터 모니터링

ECS 웹 콘솔에서 'petclinic-rest-cluster'를 선택합니다. 측정치(Metrics)탭에 들어가 보면 현재 CPU와 메모리에 대한 상태를 확인할 수 있습니다. 이 정보는 클러스터 내의 ECS 작업으로 예약된 컨테이너 인스턴스(EC2)에 대한 정보입니다. 



<p id="gdcalert87" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/AWSKRUG-container86.png). Store image on your image server and adjust path/filename if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert88">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/AWSKRUG-container86.png "image_tooltip")


우선 예약(Reservation)에 대해서 알아보겠습니다. 클러스터 예약 지표는 클러스터 내 각 활성 컨테이너 인스턴스에 대해 등록된 전체 CPU 및 메모리를 기준으로 클러스터 내 모든 Amazon ECS 작업에 의해 예약된 CPU 및 메모리의 백분율로 측정됩니다. 이 지표는 표준 시작 유형을 사용하는 작업 또는 서비스가 있는 클러스터에서만 사용되고 Fargate 시작 유형을 사용하는 모든 작업 또는 서비스와는 호환되지 않습니다.

현재 우리는 t2.medium 두개의 인스턴스를 사용하고 있습니다. 총 4GiB메모리와 2vCPU(2048유닛)를 가지고 있습니다. 작업 정의에서 작업의 메모리와 CPU가 1024MiB, 512유닛으로 제한을 설정해두었습니다. 그래서 그래프를 보게 되면 평상시에는 CPU의 경우 2개의 작업이 예약한 CPU 유닛인 1024(512 + 512)에 인스턴스 총 CPU유닛 (2048 + 2048)유닛을 나눈 백분율인 25% 인것을 확인할 수 있습니다. 배포 중에는 작업이 4개가 되므로 최대 50%가 됩니다. 메모리도 같은 방식으로 작업이 예약한 메모리인 2048MiB에 인스턴스 총 메모리인 8GiB(약 8196MiB)를 나눈 백분율인 약 25%(실제값 25.9%)인 것을 확인할 수 있습니다. 

메모리 계산에서 주의하실 점은 MB, GB가 아니라 MiB, GiB인 것입니다. 작업와 인스턴스의 크기를 고민하실 때 주의하시기 바랍니다.

클러스터 사용률(Utilzation) 지표는 클러스터 내 각 활성 컨테이너 인스턴스에 대해 등록된 전체 CPU 및 메모리를 기준으로 클러스터 내 모든 Amazon ECS 작업에 의해 사용된 CPU 및 메모리의 백분율로 측정됩니다. 이 지표는 표준 시작 유형을 사용하는 작업 또는 서비스가 있는 클러스터에서만 사용되고 Fargate 시작 유형을 사용하는 모든 작업 또는 서비스와는 호환되지 않습니다.

관련 링크 :[https://docs.aws.amazon.com/ko_kr/AmazonECS/latest/developerguide/cloudwatch-metrics.html#cluster_reservation](https://docs.aws.amazon.com/ko_kr/AmazonECS/latest/developerguide/cloudwatch-metrics.html#cluster_reservation)


### 6.2 서비스 모니터링

이번에는 서비스에 대한 모니터링을 해보겠습니다. 클러스터 화면에서 서비스 탭을 클릭하고 'petclinic-rest-service'을 선택합니다. 서비스 화면에서 측정치(Metrics) 탭을 선택합니다. 서비스 사용률 지표는 서비스의 작업 정의에 지정된 CPU 및 메모리를 기준으로 클러스터의 특정 서비스에 속하는 Amazon ECS 작업이 사용하는 CPU 및 메모리의 백분율로 측정됩니다. 



<p id="gdcalert88" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/AWSKRUG-container87.png). Store image on your image server and adjust path/filename if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert89">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/AWSKRUG-container87.png "image_tooltip")


앞서 이야기했듯이, 작업 정의에서 작업의 메모리와 CPU가 1024MiB, 512유닛으로 제한을 설정해두었습니다. 

CPU의 경우 배포하고 앱을 실행하는 시점에는 최대 100% 가깝게 사용하다가 배포가 마무리 되면 안정화가 되고 있습니다. CPU의 경우에는 100% 이상을 사용할 수 있습니다. 512유닛으로 제한을 해두었지만 현재 2048유닛을 가진 인스턴스에서 512만 예약되어있고 나머지는 유휴하기 때문에 사용가능합니다. 그래서 현재 차트에도 순간 최대 사용률이 100%를 넘는 경우를 보실 수 있습니다. 

메모리는 반대로 시간이 지날수록 점점 사용량이 올라는 모습을 볼 수 있습니다. 메모리는 작업 정의에서 제한을 하면 하드 제한(Hard Limit)가 되어 100%이상 사용할 수 없습니다. 

관련링크 : [https://docs.aws.amazon.com/ko_kr/AmazonECS/latest/developerguide/cloudwatch-metrics.html#service_utilization](https://docs.aws.amazon.com/ko_kr/AmazonECS/latest/developerguide/cloudwatch-metrics.html#service_utilization)


### 6.3 CloudWatch에서 보기

같은 내용을 CloudWatch에서도 확인할 수 있습니다. CloudWatch 웹 콘솔로 들어가서 좌측의 지표(Metrics) 메뉴를 클릭합니다. 모든 지표에서 ECS를 클릭합니다. 



<p id="gdcalert89" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/AWSKRUG-container88.png). Store image on your image server and adjust path/filename if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert90">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/AWSKRUG-container88.png "image_tooltip")


클러스터의 지표를 확인하려면 ClusterName을 선택합니다. 서비스의 지표는 ClusterName, Service Name을 선택하면 됩니다. 여기에 표시되는 문구들은 차원(Dimension)이라고 합니다. 데이터의 속성이라고 볼 수 있습니다. 예를 들어, 클러스터에 대한 지표는 클러스터 이름이란 하나의 차원을 가진 데이터 입니다. 그리고 서비스에 대한 지표는 클러스터 이름과 서비스 이름 두개의 차원을 가진 지표입니다.



<p id="gdcalert90" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/AWSKRUG-container89.png). Store image on your image server and adjust path/filename if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert91">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/AWSKRUG-container89.png "image_tooltip")


ClusterName을 선택하면 지표들이 나옵니다. 지표를 클릭하면 기본적으로 위에서 라인 차트를 그려줍니다. Cloud 메모리의 예약과 사용량에 대해서 동시에 보고 싶어서 두개를 선택해 보았습니다. 기본적으로 보통(평균)값으로 차트를 구성합니다. 



<p id="gdcalert91" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/AWSKRUG-container90.png). Store image on your image server and adjust path/filename if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert92">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/AWSKRUG-container90.png "image_tooltip")


CloudWatch 지표를 가지고 차트를 구성한 다음, 그 차트들을 취합해서 대시보드를 만들 수 있습니다. 또한 이 지표값이 비정상적인 경우를 정의해서 알람을 할 수도 있습니다. 자세한 내용은 CloudWatch 기술 문서를 확인해보세요.


## 7. 오토스케일링

petclinic 서비스가 잘 되면서 가끔 감당하기 어려운 트래픽이 오는 경우가 생겼습니다. 그래서 트래픽이 늘어나는 경우를 대비하여 오토 스케일링이 되도록 설정하려고 합니다. 

오토스케일링은 굉장히 까다로운 작업입니다. 해당 서비스의 특성, 트래픽의 특성 등을 고려하여 정책을 결정해야 합니다. 특히 EC2 기반의 ECS 인프라에서는 서비스의 오토스케일링 뿐만 아니라 ECS 컨테이너 인스턴스(EC2)에 대한 오토스케일링까지 고려해야 하기 때문에 굉장히 까다롭습니다. 그리고 늘어나고 줄어드는 것을 확인하는데 오랜 시간이 필요합니다. 최대한 쉬운 방식으로 진행할 것이며 여유를 가지고 따라해보시기 바랍니다.


### 7.1 서비스 오토스케일링

시작하기에 앞서 두가지 조정(Scaling) 정책에 대해서 알아보겠습니다.

첫번째는 대상 추적 정책입니다. 

"특정 측정치에 대한 대상 값을 기준으로 서비스가 실행하는 작업의 수를 늘리거나 줄입니다. 이 과정은 온도 조절기를 사용하여 집안 온도를 유지하는 방법과 비슷합니다. 사용자가 온도를 선택하면 나머지는 모두 온도 조절기에서 자동으로 수행됩니다."

예를 들어 CPU 사용량 지표값이 50%가 되도록 대상추적 정책을 정했다면 작업을 늘이거나 줄이면서 50%를 유지하도록 합니다.

두번째는 단계 조정 정책입니다.

"일련의 조정 조절(경보 위반의 크기에 따라 달라지는 단계 조절)을 기준으로 서비스가 실행하는 작업의 수를 늘리거나 줄입니다."

예를 들어, CPU 사용량이 50% ~ 60%가 되면 인스턴스를 20% 증가시키고 60% ~ 80%가 되면 인스턴스를 40%를 증가시키는 식의 구체적인 기준을 가지고 작업이 늘어나고 줄어듭니다. 

대상 추적 정책이 단계 조정 정책에 비해서 비교적 쉽습니다. 왜냐하면 단계 조정 정책은 사용자가 구체적인 기준을 모두 정해야하기 때문입니다. 그 기준을 정하는 것 자체가 많은 시행착오가 필요합니다. 그래서 우리는 대상 추적 정책으로 서비스 오토스케일링을 진행할 것입니다.

그 전에 작업 정의를 업데이트 하겠습니다. 현재 작업에 전체에 대해서 1024MiB로 제한을 걸었는데 이것을 컨테이너의 소프트 제한(625MiB)만 걸고 작업 정의 전체의 제한은 풀도록 하겠습니다. 그 이유는 인스턴스 메모리가 4GiB(4096MiB)라고 되어있지만 작업 입장에서 인스턴스의 가용 메모리가 4GiB 보다 조금 작기 때문입니다. 그렇기 때문에 엄격하게 작업마다 1024MiB를 예약하게 되면 인스턴스 안에서 4개의 작업을 실행할 수 없습니다.  (모니터링에서 인스턴스의 메모리 예약 크기가 25.9%로 나온것입니다.) 최신 작업 정의를 선택하여 '새 개정 생성'을 클릭합니다. 작업 메모리 입력 영역을 비우고 생성합니다.



<p id="gdcalert92" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/AWSKRUG-container91.png). Store image on your image server and adjust path/filename if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert93">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/AWSKRUG-container91.png "image_tooltip")
 



<p id="gdcalert93" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/AWSKRUG-container92.png). Store image on your image server and adjust path/filename if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert94">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/AWSKRUG-container92.png "image_tooltip")


이제 계산을 해보겠습니다. 우리의 컴퓨팅 자원을 생각해보면 t2.medium 인스턴스가 2대가 있습니다. 총 4vCPU와 8GiB의 자원이 있습니다. 그리고 평상시에 예약하고 있는 자원을 생각해보면 작업 2개가 총 1vCPU와 1250MiB(컨테이너 소프트제한)를 예약하여 사용하고 있습니다. 한 인스턴스 내에서 4개의 작업이 실행가능합니다. 이제 오토스케일링 설정을 진행하겠습니다. 

ECS 웹 콘솔 클러스터 메뉴에서 'petclinic-rest-cluster'를 선택하고 서비스 탭에서 'petclinic-rest-service'를 선택합니다. 그리고 우측 상단에 업데이트를 클릭합니다.



<p id="gdcalert94" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/AWSKRUG-container93.png). Store image on your image server and adjust path/filename if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert95">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/AWSKRUG-container93.png "image_tooltip")


서비스 구성과 네트워크 구성은 그대로 두고 오토스케일링 구성으로 넘어갑니다. 오토스케일링을 구성하는 라이오 박스를 선택합니다. 최소 작업 개수는 2개로 설정하고 원하는 작업 개수도 2개로 설정합니다. 그리고 최대 작업 개수를 8개로 설정합니다.



<p id="gdcalert95" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/AWSKRUG-container94.png). Store image on your image server and adjust path/filename if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert96">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/AWSKRUG-container94.png "image_tooltip")




<p id="gdcalert96" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/AWSKRUG-container95.png). Store image on your image server and adjust path/filename if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert97">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/AWSKRUG-container95.png "image_tooltip")


그 다음 조정 정책을 추가합니다. 

<p id="gdcalert97" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/AWSKRUG-container96.png). Store image on your image server and adjust path/filename if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert98">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/AWSKRUG-container96.png "image_tooltip")


앞서 설명한 대상 추적을 선택합니다. 정책 이름에는 'cpu-target-tracking-55percent-policy'라고 입력합니다. 서비스 측정치는 ECS 서비스의 평균 CPU 사용량입니다. 대상값을 55로 입력합니다. 55%에 대해서 항상성을 유지하도록 노력할 것입니다. 확장 휴지 기간과 축소 휴지 기간은 150초로 설정합니다. 기본값은 300초인데 5분을 좀 더 동작하도록 반으로 줄였습니다. 그리고 저장합니다.



<p id="gdcalert98" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/AWSKRUG-container97.png). Store image on your image server and adjust path/filename if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert99">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/AWSKRUG-container97.png "image_tooltip")




<p id="gdcalert99" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/AWSKRUG-container98.png). Store image on your image server and adjust path/filename if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert100">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/AWSKRUG-container98.png "image_tooltip")


저장 후에 다음 단계로 넘어갑니다. 검토를 하고 업데이트를 마무리합니다. 완료가 되면 ECS 서비스 화면의 오토스케일링 탭에서 정보를 확인할 수 있습니다. 오토스케일링의 동작에 중요한 역할을 하는 경보(Alarm)이 만들어졌습니다. CloudWatch 웹 콘솔에서 경보 메뉴를 클릭해봅니다. 



<p id="gdcalert100" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/AWSKRUG-container99.png). Store image on your image server and adjust path/filename if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert101">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/AWSKRUG-container99.png "image_tooltip")


경보를 이해하기 위해서는 기간, 평가 기간(Evaluation Period), 경보에 대한 데이터포인트(Datapoints to Alarm)에 대해서 알 필요가 있습니다. 

기간은 해당 지표를 평가하는 시간입니다. 현재 오토스케일링 경보의 경우에는 기간이 1분으로 설정되어있습니다. 1분에 한번씩 지표값을 확인합니다. 

평가 기간은 경보 상태를 결정할 때 평가할 가장 최근 데이터 포인트의 수입니다. 'petclinic-rest-service-AlarmHigh'의 경우에는 3분으로 설정되어있습니다. 최근 3분 동안을 평가한다는 의미입니다. 

경보에 대한 데이터 포인트는 평가 기간 동안 임계값을 몇 번 넘었는지 나타내는 수입니다. 'petclinic-rest-service-AlarmHigh'의 경우에는 평가 기간은 3분이고 경보에 대한 데이터 포인트는 3개 입니다. 즉 최근 3분 내내 임계값을 넘게 되면 경보를 울리게 됩니다. 만약 평가기간이 5분이고 경보에 대한 데이터 포인트가 3개라면 5분동안 3번만 임계값을 넘으면 되고 연속적일 필요는 없습니다. 

앞서 기술하였듯이 'petclinic-rest-service-AlarmHigh'는 3분(평가기간)동안 1분(기간)에 한번씩 3번(경보에 대한 데이터 포인트)  CPU 사용율이 55%를 넘게 되면 작업을 추가적으로 실행합니다. 'petclinic-rest-service-AlarmLow'는 15분 동안 1분에 한번씩 15번 CPU 사용율이 49.5% 이하가 되면 작업들을 줄이기 시작합니다. 이 값들은 대상값을 55%로 입력하게 되면 자동으로 설정됩니다.

이제 테스트를 위해서 서버에 부하를 주도록 하겠습니다. cloud9 터미널에 접속합니다. ab라는 명령어를 통해서 부하를 줄 것입니다. 


```
ab -n {총횟수} -c {동시에 요청하는 개수} {로드밸런서 DNS 이름}/test/stress
```


총 회수는 1만회 입니다. 동시에 5개씩 요청을 보냅니다. 주소는 로드밸런서의 DNS 이름 뒤에 '/test/stress'라고 붙이면 됩니다. 어떻게 부하를 주는 지는 cloud9에서 petclinic-rest > src > main > java > vw >demo > petclinic > interfaces > tests > StressTestController.java 파일을 확인해보시면 알 수 있습니다. 한번 호출하면 보통 2~4초 걸리는 요청이기 때문에 이 명령어를 완료하려면 한시간 이상이 걸립니다.



<p id="gdcalert101" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/AWSKRUG-container100.png). Store image on your image server and adjust path/filename if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert102">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/AWSKRUG-container100.png "image_tooltip")


여유를 가지고 기다려 보면 CPU의 사용량이 증가하는 것을 확인할 수 있습니다. ECS 서비스 화면에서 이벤트 탭을 모니터링 합니다. 곧 경보가 발생하고 경보에 의해서 작업 개수(desired count)가 변경되는 것을 확인할 수 있습니다.



<p id="gdcalert102" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/AWSKRUG-container101.png). Store image on your image server and adjust path/filename if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert103">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/AWSKRUG-container101.png "image_tooltip")


약 한시간 뒤에 CloudWatch의 경보 화면을 확인해보았습니다. 트래픽은 계속 들어오고 있으며 CPU 사용률이 줄어들긴 했지만 우리가 원하는 만큼(55%) 줄어들지는 않았습니다. 작업은 더 이상 실행할 수 없습니다. 이제는 컨테이너 인스턴스를 더 추가해야할 때입니다. 



<p id="gdcalert103" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/AWSKRUG-container102.png). Store image on your image server and adjust path/filename if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert104">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/AWSKRUG-container102.png "image_tooltip")


인스턴스를 추가해보겠습니다. ECS 웹 콘솔 클러스터 메뉴에서 'petclinic-rest-cluster'를 선택하고 ECS 인스턴스 탭을 클릭합니다. ECS 인스턴스 조정 버튼을 클릭합니다. 



<p id="gdcalert104" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/AWSKRUG-container103.png). Store image on your image server and adjust path/filename if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert105">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/AWSKRUG-container103.png "image_tooltip")


그리고 원하는 인스턴스 개수를 3개로 늘립니다. 



<p id="gdcalert105" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/AWSKRUG-container104.png). Store image on your image server and adjust path/filename if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert106">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/AWSKRUG-container104.png "image_tooltip")


조금 시간이 지나면 인스턴스가 생성됩니다. 



<p id="gdcalert106" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/AWSKRUG-container105.png). Store image on your image server and adjust path/filename if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert107">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/AWSKRUG-container105.png "image_tooltip")


서비스 업데이트를 통해서 최대 작업 개수를 12개로 업데이트 합니다. 



<p id="gdcalert107" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/AWSKRUG-container106.png). Store image on your image server and adjust path/filename if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert108">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/AWSKRUG-container106.png "image_tooltip")


바로 작업 개수를 10개로 늘리는 것을 확인할 수 있습니다. 



<p id="gdcalert108" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/AWSKRUG-container107.png). Store image on your image server and adjust path/filename if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert109">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/AWSKRUG-container107.png "image_tooltip")


이제 10000개의 리퀘스트가 종료되었습니다. 만약 아직도 실행중이라면 꺼보겠습니다. 그리고 실제로 줄어드는 지 확인해보겠습니다. 트래픽이 멈춘지 30분 쯤 지난 시점으로 5개로 줄어들었습니다. 하나씩 하나씩 줄이고 있습니다.



<p id="gdcalert109" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/AWSKRUG-container108.png). Store image on your image server and adjust path/filename if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert110">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/AWSKRUG-container108.png "image_tooltip")



### 7.2 ECS 인스턴스 오토스케일링

트래픽이 계속 늘어나고 서비스가 더 이상 추가적으로 작업을 실행할 수 없을 때 ECS 인스턴스를 추가해야합니다. 이전 단계에서는 ECS 클러스터의 ECS 인스턴스 탭에서 수동으로 개수를 추가했습니다. 이번에는 서비스 오토스케일링 처럼 ECS 인스턴스에 대해서 오토스케일링을 해보겠습니다. 

이 장의 도입부에서 미리 설명했듯이 서비스의 오토스케일링과 ECS 오토스케일링을 동시에 하려면 굉장히 복잡하고 테스트하기도 쉽지 않습니다. 최대한 쉬운 방식으로 트래픽을 견디도록 ECS 인스턴스 오토스케일링을 설정해보겠습니다.

EC2 웹 콘솔에서 오른 쪽 하단의 메뉴 중에서 Auto Scaling 그룹이라는 메뉴를 클릭합니다. ECS를 생성할 대 CloudFormation을 통해서 자동으로 오토스케일링 그룹이 생성되었습니다. 'EC2ContainerService-petclinic-rest-cluster-EcsInstance...'라는 이름을 확인할 수 있습니다. 

선택하게 되면 세부 정보 탭에서 정보들을 확인할 수 있습니다. 



<p id="gdcalert110" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/AWSKRUG-container109.png). Store image on your image server and adjust path/filename if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert111">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/AWSKRUG-container109.png "image_tooltip")


활동기록 탭은 ECS 서비스 화면의 이벤트 탭과 비슷합니다. 인스턴스가 실행되고 종료되는 등의 상태를 확인할 수 있습니다. 조정 정책 탭은 오토스케일링 조정 정책을 생성하는 곳입니다. 조정정책은 서비스 오토스케일링과 마찬가지로 단계 조정 정책, 대상 조정 정책이 있고 추가적으로 단순 조정 정책이 있습니다. 인스턴스 탭에서는 현재 인스턴스들을 확인할 수 있습니다. 

우선 세부정보를 수정하겠습니다. 탭 우측 상단에 편집 버튼을 클릭합니다. 목표 용량을 2, 최소 2, 최대 4를 입력합니다. 최소가 0 이면 인스턴스가 모두 종료되어 서비스도 종료될 수 있습니다. 기본 휴지는 150초로 설정하여 좀 더 빨리 진행할 수 있도록 수정했습니다. 마치고 저장합니다.



<p id="gdcalert111" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/AWSKRUG-container110.png). Store image on your image server and adjust path/filename if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert112">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/AWSKRUG-container110.png "image_tooltip")


그다음 조정 정책 탭을 선택하고 새로운 조정 정책을 만들어 보겠습니다. 탭 바로 아래에 있는 정책 추가 버튼을 클릭합니다. 기본값이 대상 조정 정책입니다. 이름은 'cpu-55percent-policy'라고 입력합니다. 대상 값은 55, 인스턴스 필요 시간은 0으로 합니다. 인스턴스 필요 시간은 인스턴스가 실행된 후 워밍업하는 시간인데 우리는 워밍업할 필요가 없기 때문에 0이라고 입력합니다.



<p id="gdcalert112" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/AWSKRUG-container111.png). Store image on your image server and adjust path/filename if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert113">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/AWSKRUG-container111.png "image_tooltip")


조정 정책을 생성하고 나면 경보가 생성됩니다. AlarmHigh는 '3분 이내에 3개의 데이터 포인트에 대한 CPUUtilization > 55'이며  AlarmLow는 '15분 이내에 15개의 데이터 포인트에 대한 CPUUtilization < 41.25'입니다. 서비스 오토스케일링과 비교하여 High는 같은 조건인데 Low는 더 작습니다. (서비스 AlarmLow: 49.5)



<p id="gdcalert113" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/AWSKRUG-container112.png). Store image on your image server and adjust path/filename if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert114">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/AWSKRUG-container112.png "image_tooltip")


그리고 ECS 서비스의 최대 작업개수도 16개로 수정해줍니다. 왜냐하면 이제 ECS 인스턴스 오토스케일링을 통해서 최대 4개의 인스턴스가 실행될 수 있기 때문입니다.



<p id="gdcalert114" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/AWSKRUG-container113.png). Store image on your image server and adjust path/filename if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert115">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/AWSKRUG-container113.png "image_tooltip")


이제 서비스에 부하를 주도록 하겠습니다. 아까랑 같은 명령어에서 이번에는 더 긴 시간 동안 더 더 많은 트래픽을 주려고 합니다. 그래서 전체 10만개를 동시에 6번씩 요청하도록 하겠습니다.



<p id="gdcalert115" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/AWSKRUG-container114.png). Store image on your image server and adjust path/filename if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert116">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/AWSKRUG-container114.png "image_tooltip")


이제 또 여유를 가지고 기다려봅니다. 틈틈히 ECS 서비스의 이벤트 탭과 EC2 오토스케일링 그룹 메뉴의 활동 기록 탭, 그리고 CloudWatch에서 클러스터 cpu 사용량과 서비스 cpu 사용량 지표를 동시에 확인해봅니다. 

30분 뒤에 확인을 해봤습니다. 서비스 이벤트를 확인해보면 계속해서 작업 개수가 증가했습니다. 차례로 2개의 ECS 인스턴스가 실행이 되었고 총 13개의 작업이 동시에 실행되고 있습니다. 그리고 그 이후에는 안정적인 그래프를 그리고 있습니다. 



<p id="gdcalert116" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/AWSKRUG-container115.png). Store image on your image server and adjust path/filename if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert117">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/AWSKRUG-container115.png "image_tooltip")


이제 트래픽을 끄고 다시 확인해보겠습니다. 서비스나 인스턴스가 빠질 경우 Alarm의 평가 기간이 15분 이므로 여유를 가지고 기다려봅니다. 50분 뒤에 확인해보았습니다. 



<p id="gdcalert117" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/AWSKRUG-container116.png). Store image on your image server and adjust path/filename if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert118">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/AWSKRUG-container116.png "image_tooltip")


약 36분 부터 트래픽이 없는 상태가 되었고 15분 뒤에 인스턴스가 하나 종료되었습니다.  그 뒤에 휴지 기간 이후에 다른 인스턴스도 종료되었습니다.



<p id="gdcalert118" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/AWSKRUG-container117.png). Store image on your image server and adjust path/filename if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert119">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/AWSKRUG-container117.png "image_tooltip")


인스턴스 종료 이후에 작업 개수가 줄어들기 시작했습니다. 결국 2개로 돌아왔습니다.



<p id="gdcalert119" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/AWSKRUG-container118.png). Store image on your image server and adjust path/filename if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert120">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/AWSKRUG-container118.png "image_tooltip")


이렇게 인스턴스 오토 스케일링과 서비스 오토 스케일링을 동시에 설정하고 테스트해보았습니다. 지금은 단순한 트래픽 패턴에 단순한 정책으로 테스트를 해보았지만 사실 많은 경우의 수가 있고 그에 대해서 대비할 수 있어야합니다. 앞서 설명했듯이 트래픽의 패턴과 서비스의 특성에 맞게 정책을 잘 수립하고 노하우를 쌓아야 합니다.

사실 많은 사람들이 EC2 기반의 오토스케일링이 어렵기 때문에 Fargate를 추천합니다. 여기까지 잘 따라 오셨다면 Fargate는 쉽게 하실 수 있을 겁니다.


## 8.정리


### 8.1 마무리

'Petclinic-rest'라는 자바 기반의 백앤드 서비스를 EC2 기반의 ECS를 이용해서 서비스를 운영하는 것을 살짝 경험해보았습니다. 익숙해지기 위해서 두번 정도 반복해서 따라하는 것을 추천합니다. 웹 콘솔에서 ECS와 기타 도구들의 개념과 사용법에 익숙해 지신다면 나중에 CLI나 기타 도구들을 이용해서 더 쉽게 서비스를 구축할 수 있을 것입니다. 

그리고 같은 실습을 Fargate로도 한번 해보세요. (2018년 10월 현재)싱가포르 리전, 도쿄 리전에서 사용가능합니다. EC2를 관리하던 불편함이 사라져 매우 편리하게 서비스를 운영할 수 있습니다.

'AWS에서 컨테이너식 애플리케이션을 쉽게 실행하고 확장 및 축소'할 수 있다고 했는데 입력해야할 것과 옵션들이 매우 많았습니다. 또한 운영을 위해서는 ECS 말고도 보안그룹, 로드밸런서, 오토스케일링 그룹, CodeBuild, CodePipeline 같은 자동화 도구, CloudWatch 같은 모니터링 도구들이 필요했습니다. 결코 쉽지 않았습니다. 고생많으셨습니다. 실제로 ECS나 컨테이너 기반의 오케스트레이션 도구를 이용하는데 도움이 되시길 바랍니다.


### 8.2 삭제

중요한 부분입니다. 이 실습은 AWS의 프리티어 범위를 벗어납니다. 실제로 사용하는 서비스가 아니라면 꼭 삭제해주세요.


#### 클러스터 삭제

우선 클러스터를 삭제합니다. 내부적으로 관련된 많은 것들이 같이 삭제됩니다. 우리가 수정한 것 중에는 오토스케일링 그룹이 같이 삭제됩니다. 클러스터 화면에서 오른 쪽 상단의 클러스터 삭제 버튼을 클릭합니다. 클러스터 삭제는 좀 오래걸립니다. 클러스터가 삭제되기 때문에 오토스케일링 관련된 경보들도 모두 삭제됩니다. 



<p id="gdcalert120" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/AWSKRUG-container119.png). Store image on your image server and adjust path/filename if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert121">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/AWSKRUG-container119.png "image_tooltip")



#### ECR 삭제

ECR 리포지토리는 리포지토리를 선택하고 상단의 리포지토리 삭제 버튼으로 삭제 가능합니다.



<p id="gdcalert121" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/AWSKRUG-container120.png). Store image on your image server and adjust path/filename if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert122">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/AWSKRUG-container120.png "image_tooltip")



#### 작업 정의 등록 취소

작업 정의는 삭제가 아닌 등록 취소만 가능합니다. 그리고 등록 취소한 작업 정의는 검색 가능합니다. 



<p id="gdcalert122" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/AWSKRUG-container121.png). Store image on your image server and adjust path/filename if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert123">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/AWSKRUG-container121.png "image_tooltip")



#### 대상그룹 삭제

이제 EC2 콘솔로 이동합니다. 메뉴에서 대상그룹을 클릭합니다. 'petclinic-rest-target'을 선택하고 작업 버튼을 클릭하고 삭제를 클릭합니다. 


#### 로드밸런서 삭제

EC2 콘솔에서 로드밸런서 메뉴를 클릭합니다. 'petclinic-rest-alb'를 선택하고 작업 버튼을 클릭하고 삭제를 클릭합니다.


#### 보안그룹 삭제

EC2 콘솔에서 보안그룹 메뉴를 클릭합니다. 'Petclinic-rest-alb-sg', 'petclinic-rest-ecs-instance-sg'를 선택하고 삭제합니다. 


#### 키페어 삭제

EC2 콘솔에서 키페어 메뉴를 클릭합니다. 'petclinic'를 선택하고 삭제합니다.


#### CodeBuild, CodePipeline 삭제

개발자 도구 웹 콘솔로 이동합니다. 왼쪽 메뉴에서 CodeBuild를 클릭합니다. 그리고 그 아래에 있는 프로젝트 빌드를 클릭합니다. 그중에 'petclinic-rest-build'을 선택한다. 우측 상단에 삭제 버튼으로 삭제합니다.



<p id="gdcalert123" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/AWSKRUG-container122.png). Store image on your image server and adjust path/filename if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert124">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/AWSKRUG-container122.png "image_tooltip")


그 다음 왼쪽 메뉴에서 CodePipeline을 클릭합니다. 그 아래에 있는 파이프라인을 클릭합니다. 'petclinic-rest-codepipeline'을 선택합니다. 우측 상단에 있는 편집 버튼을 누르고 삭제 버튼을 눌러 삭제합니다.



<p id="gdcalert124" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/AWSKRUG-container123.png). Store image on your image server and adjust path/filename if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert125">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/AWSKRUG-container123.png "image_tooltip")



#### Cloud9 삭제

Cloud9 웹 콘솔로 이동합니다. petclinic-cloud9을 선택하고 삭제합니다.



<p id="gdcalert125" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/AWSKRUG-container124.png). Store image on your image server and adjust path/filename if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert126">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/AWSKRUG-container124.png "image_tooltip")



<!-- GD2md-html version 1.0β13 -->
